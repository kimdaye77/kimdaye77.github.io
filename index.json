[{"content":"","date":null,"permalink":"/","section":"","summary":"","title":""},{"content":"우테코 프리코스 2주차 # 자동차 경주 fork repository 1주차와 동일하게 내 레포지토리로 포크하고 클론해서 작업을 진행한다.\n구현할 기능 목록 # 과제 요구 사항에서 기능 구현 전, docs/README.md에 구현할 기능 목록을 정리할 것을 명시하고 있다.\n# 미션 - 자동차 경주 ## ✏️ 구현할 기능 목록 ### `App.js`의 `play` 메서드를 통해 프로그램 시작 - [x] play 메서드 생성 ### 자동차 경주 로직 - [x] 사용자 입력(자동차 이름) - 자동차 입력 안내 문구 출력\u0026lt;br\u0026gt; `경주할 자동차 이름을 입력하세요.(이름은 쉼표(,) 기준으로 구분)` - 잘못된 값 입력 시 **throw문을 통해 예외 발생 및 애플리케이션 종료**\u0026lt;br\u0026gt; - 쉼표를 기준으로 알파벳으로 구성 x - 각 이름이 5자 초과인 경우 - [x] 사용자 입력(경주 시도 횟수) - 시도 횟수 입력 안내 문구 출력\u0026lt;br\u0026gt; `시도할 횟수는 몇 회인가요?` - 잘못된 값 입력 시 **throw문을 통해 예외 발생 및 애플리케이션 종료**\u0026lt;br\u0026gt; - 숫자 이외의 값 - [x] 경주 실행 결과 출력 - 경주 시도 횟수 만큼 반복문 - 컴퓨터 임의의 수 선택 - `Random API`를 이용하여 0-9 사이 값 선택 - 4 이상이면 자동차 전진 ### 자동차 경주 게임 완료 - [x] 우승자 안내 문구 출력 `최종 우승자 : ${우승한 자동차}` - 여러 명일 경우 쉼표(,)로 구분 ### 게임 종료 - [x] 게임 종료 안내 문구 출력 `게임을 새로 시작하려면 1, 종료하려면 2를 입력하세요.` - [x] 사용자 입력 - 잘못된 값 입력 시 **throw문을 통해 예외 발생 및 애플리케이션 종료**\u0026lt;br\u0026gt; - 1, 2 이외의 값을 입력 받은 경우 - [x] 사용자 입력에 따라 게임 다시 시작 또는 완전히 종료 - 1을 입력받았을 경우: 게임 재시작 - [숫자 야구 게임 로직](#숫자-야구-게임-로직)부터 실행 - 2를 입력받았을 경우: 게임 완전히 종료 회고 # 예외 사항 # 이번에 어려웠던 점은 구현할 기능 목록을 할 때, 예외 사항을 고려하는 것이었다. 내가 너무 깊게 생각해서인지\n자동차 이름은 쉼표(,)를 기준으로 구분하며 이름은 5자 이하만 가능하다. 사용자는 몇 번의 이동을 할 것인지를 입력할 수 있어야 한다. 위와 같은 경우에 대해서, 발생할 수 있는 모든 예외 사항을 생각하려고 했다. 예를 들어, 알파벳만 가능한지 등등\u0026hellip; 예외 사항을 어디까지 생각해야하는지 기준이 어려웠다.\n💡 해결 방법\n결과적으로는 스켈레톤 코드와 함께 제공되는 StringTest.js 파일을 참고함으로써 테스트 통과 기준만 최소 만족하도록 작성하였다.\nIndent depth # 이번 추가 요구 사항 항목 中\nindent(인덴트, 들여쓰기) depth를 3이 넘지 않도록 구현한다. 2까지만 허용한다. 예를 들어 while문 안에 if문이 있으면 들여쓰기는 2이다. 힌트: indent(인덴트, 들여쓰기) depth를 줄이는 좋은 방법은 함수(또는 메소드)를 분리하면 된다. 가 포함되어 있었기 때문에 이 부분을 신경써서 설계했다.\n💡 해결 방법\n나는 설계를 Car.js, RacingGame.js 클래스들을 만들어서 각각 차와 경주 게임 객체를 생성하도록 코드를 구현하였다. 그리고 playRaceGame.js 파일에 필요한 함수들을 작성해서 경주 게임 객체를 매개 변수로 넘겨줌으로써 경주 게임 객체가 가지고 있는 constructor(차 객체들, 시도 횟수) 정보들을 알려주도록 하였다. 더 좋은 방법이 있을 것 같기도 하지만 우선 최선으로 이렇게 설계해보았다. (Do my best ㅎㅎ)\n✔️ 최종 결과 💯\n이번엔 테스트가 ApplicationTest.js와 StringTest.js로 2개였다. 결과는 모두 통과!!\n👇🏻 아래는 PR 링크이다. 👇🏻\nPR\npr링크를 제출하면 위와 같이 예제 테스트가 모두 통과하는 것을 확인할 수 있다.\n","date":"30 October 2023","permalink":"/posts/woowacourse-precourse/precourse2/","section":"Posts","summary":"우테코 프리코스 2주차 # 자동차 경주 fork repository 1주차와 동일하게 내 레포지토리로 포크하고 클론해서 작업을 진행한다.","title":"[우테코 프리코스] 자동차 경주 #2"},{"content":"","date":null,"permalink":"/categories/","section":"Categories","summary":"","title":"Categories"},{"content":"","date":null,"permalink":"/posts/","section":"Posts","summary":"","title":"Posts"},{"content":"","date":null,"permalink":"/tags/","section":"Tags","summary":"","title":"Tags"},{"content":"","date":null,"permalink":"/tags/%EC%9A%B0%ED%85%8C%EC%BD%94/","section":"Tags","summary":"","title":"우테코"},{"content":"","date":null,"permalink":"/categories/%EC%9A%B0%ED%85%8C%EC%BD%94-%ED%94%84%EB%A6%AC%EC%BD%94%EC%8A%A4/","section":"Categories","summary":"","title":"우테코 프리코스"},{"content":"","date":null,"permalink":"/tags/%EC%9E%90%EB%8F%99%EC%B0%A8%EA%B2%BD%EC%A3%BC/","section":"Tags","summary":"","title":"자동차경주"},{"content":"","date":null,"permalink":"/tags/%ED%94%84%EB%A6%AC%EC%BD%94%EC%8A%A4/","section":"Tags","summary":"","title":"프리코스"},{"content":"우테코 프리코스 1주차 # 숫자 야구 게임 fork repository 메일로 레포지토리 저장소를 보내준다. 레포지토리 저장소에 들어가서, fork 후에 자신의 깃허브 아이디로 브랜치를 생성하고 그곳에서 작업을 하면 된다.\n구현할 기능 목록 # 과제 요구 사항에서 기능 구현 전, docs/README.md에 구현할 기능 목록을 정리할 것을 명시하고 있다.\n# 미션 - 숫자 야구 ## ✏️ 구현할 기능 목록 ### `App.js`의 `play` 메서드를 통해 프로그램 시작 - [x] play 메서드 생성 - [x] 게임 시작 문구 출력 `숫자 야구 게임을 시작합니다.` ### 숫자 야구 게임 로직 - [x] 컴퓨터 임의의 수 선택 - `Random API`를 이용하여 서로 다른 수로 이루어진 3자리의 수 선택 - [x] 사용자 입력 안내 문구 출력 `숫자를 입력해주세요 :` - [x] 사용자 숫자 입력 - 잘못된 값 입력 시 **throw문을 통해 예외 발생 및 애플리케이션 종료** - 3자리 수가 아닌 경우 - 서로 다른 수가 아닌 경우 - [x] 사용자 입력에 대한 결과 출력 - 사용자 숫자 입력 단계로 다시 돌아가는 경우 - 하나 이상 맞혔을 경우: 볼, 스트라이크 개수로 표시 - 하나도 없는 경우: 낫싱 - [게임 종료](#게임-종료)로 이동 - 3개의 숫자를 모두 맞힐 경우 ``` 3스트라이크 3개의 숫자를 모두 맞히셨습니다! 게임 종료 ``` ### 게임 종료 - [x] 게임 종료 안내 문구 출력 `게임을 새로 시작하려면 1, 종료하려면 2를 입력하세요.` - [x] 사용자 입력 - 잘못된 값 입력 시 **throw문을 통해 예외 발생 및 애플리케이션 종료**\u0026lt;br\u0026gt; - 1, 2 이외의 값을 입력 받은 경우 - [x] 사용자 입력에 따라 게임 다시 시작 또는 완전히 종료 - 1을 입력받았을 경우: 게임 재시작 - [숫자 야구 게임 로직](#숫자-야구-게임-로직)부터 실행 - 2를 입력받았을 경우: 게임 완전히 종료 회고 # 입력 # App.js 파일을 실행할 때 output만 나오고 터미널에서 입력이 안되었다.\n💡 해결 방법\nCode runner extension에서 integrated terminal에서 run을 할 수 있도록 체크가 안되어 있었다. 따라서 체크를 해주고 다시 실행하면 입력 가능!\n테스트 코드 # 코드를 다 작성하고 테스트를 돌리니까 다음과 같은 에러가 발생했다.\n구글링해보니 test 시에 async가 종료되지 않고 기다리는 것이라고 한다. package.json에 forceExit을 추가해서 강제 종료하는 방법도 있지만 좋지 않은 방법이라고 생각해서 다음과 같이 시도를 해보았다.\n🔨 시도 1\n첫 번째 시도는 await으로 비동기 처리를 안 했다고 생각해서 async 모듈인 startGame과 handleExitInput들을 각각 주석 처리를 해보았다. 하지만 여전히 test를 실행하면 같은 경고🚨가 발생했다.\n💡 해결 방법\n테스트 코드를 오랜 시간 보고 설마..하면서 내가 실행하려고 작성한 코드를 제거하니까 경고문이 사라졌다. 아래는 제거한 코드이다. # ApplicationTest.js test(\u0026#34;예외 테스트\u0026#34;, async () =\u0026gt; { // given const randoms = [1, 3, 5]; const answers = [\u0026#34;1234\u0026#34;]; mockRandoms(randoms); mockQuestions(answers); // when \u0026amp; then const app = new App(); await expect(app.play()).rejects.toThrow(\u0026#34;[ERROR]\u0026#34;); }); 테스트 코드 중 한 부분을 가져와서 설명하자면, 결론은 테스트 코드 자체에서 App() 객체를 생성하여 play() 메소드를 실행하기 때문에 내가 따로 만든 코드는 test안에 종료되지 않은 비동기 작업으로 남아있는 것이었다. 따라서 jest가 test가 완료되고 1초 후에도 exit되지 않았다.라는 경고가 발생한 것이다.\n✔️ 최종 결과 💯\n이제 테스트는 모두 통과해서 리팩토링 과정만 남았다. 현재, 메시지 프롬프트들을 constants.js/messages.js로 분리하는 것까지 진행한 상태이다.\n이후 할 것 # startGame 함수 이름 수정 this.gameState의 flag 값 상수 처리 👇🏻 아래는 PR 링크이다. 👇🏻\nPR\n","date":"21 October 2023","permalink":"/posts/woowacourse-precourse/precourse1/","section":"Posts","summary":"우테코 프리코스 1주차 # 숫자 야구 게임 fork repository 메일로 레포지토리 저장소를 보내준다.","title":"[우테코 프리코스] 숫자 야구 게임 #1"},{"content":"","date":null,"permalink":"/tags/%EC%88%AB%EC%9E%90%EC%95%BC%EA%B5%AC/","section":"Tags","summary":"","title":"숫자야구"},{"content":"Cartag 프로젝트 #5 # 오늘은 [Project] Cartag 프로젝트 #4에서 설명한 드래그 앤 드롭기능을 구현하다가 생긴 경고를 해결하면서 알아낸 것들을 정리하고자 한다.\n뒤늦게 만난 Warning 🚨 # Over 200 classes were generated for component styled.section. Consider using the attrs method, together with a style object for frequently changed styles.\n이라는 경고가 나타난 것을 모르고 있었다가 팀원 분께서 말해서 고치려고 검색해보았다.\n무슨 경고냐면 아래와 같이 top, left를 동적으로 state인 offset으로 줬다. 여기서 드래그할 때 offset이 바뀌면 스타일 컴포넌트가 렌더링되면서 class가 너무 많이 변경된다고 경고하는 것이다. 이렇게 동적인 속성은 스타일 컴포넌트의 attrs를 통해 인라인 스타일로 바꾸라고 메시지에서 알려준다.\nconst StatusBox = styled.div\u0026lt;{ $offset: IOffset; $isover: boolean; $isopen: boolean; }\u0026gt;` position: fixed; min-width: 343px; z-index: 1000; top: ${({ $offset }) =\u0026gt; $offset.offsetY}; left: ${({ $offset }) =\u0026gt; $offset.offsetX}; transform: ${({ $offset }) =\u0026gt; $offset.offsetX === \u0026#34;50%\u0026#34; ? \u0026#34;translateX(-50%)\u0026#34; : null}; (중략)cursor: pointer; `; 변경 후 코드 (attrs 버전) # \u0026lt;StatusBox ref={barRef} $isover={isOverBudget} $isopen={isOpen} onMouseDown={handleMouseDown} {...props} $offset={offset} \u0026gt; 위에서 스타일 컴포넌트에 attrs 메소드를 사용해서 $offset 속성 값을 전달해준다. 스타일 컴포넌트의 attrs 메소드는 컴포넌트에 HTML 속성을 부여해준다. 위의 코드에서 $offset은 styled.div 컴포넌트의 attrs 메소드 내에서 정의되고, 해당 컴포넌트의 스타일을 설정하는 데 사용된다. 아래에서 style을 지정해주는 것을 확인할 수 있다.\n# PriceStaticBar.tsx const StatusBox = styled.div.attrs\u0026lt;{ $isover: boolean; $isopen: boolean; $offset: IOffset; }\u0026gt;(({ $offset }) =\u0026gt; ({ style: { left: $offset.offsetX, top: $offset.offsetY, transform: $offset.offsetX === \u0026#39;50%\u0026#39; ? \u0026#39;translateX(-50%)\u0026#39; : \u0026#39;none\u0026#39;, }, }))` ${({ $isover }) =\u0026gt; !$isover \u0026amp;\u0026amp; withinBudgetCss} ${({ $isover }) =\u0026gt; $isover \u0026amp;\u0026amp; overBudgetCss} position: fixed; min-width: 343px; z-index: 1000; padding: 0px 16px; border-radius: 10px; backdrop-filter: blur(3px); 위와 같이 자주 바뀌는 offset의 경우 attrs 메소드를 이용했다.\n해당 PR # [FIX] #205: 드래그 시 스타일 컴포넌트 많이 생기는 경고 해결\n","date":"14 August 2023","permalink":"/posts/cartag/%ED%94%84%EB%A1%9C%EC%A0%9D%ED%8A%B85/","section":"Posts","summary":"Cartag 프로젝트 #5 # 오늘은 [Project] Cartag 프로젝트 #4에서 설명한 드래그 앤 드롭기능을 구현하다가 생긴 경고를 해결하면서 알아낸 것들을 정리하고자 한다.","title":"[Project] Cartag 프로젝트 #5"},{"content":"","date":null,"permalink":"/tags/%EB%A6%AC%EC%95%A1%ED%8A%B8/","section":"Tags","summary":"","title":"리액트"},{"content":"","date":null,"permalink":"/tags/%ED%83%80%EC%9E%85%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8/","section":"Tags","summary":"","title":"타입스크립트"},{"content":"","date":null,"permalink":"/tags/%ED%94%84%EB%A1%9C%EC%A0%9D%ED%8A%B8/","section":"Tags","summary":"","title":"프로젝트"},{"content":"","date":null,"permalink":"/categories/%ED%98%84%EB%8C%80-%EC%86%8C%ED%94%84%ED%8B%B0%EC%96%B4/","section":"Categories","summary":"","title":"현대 소프티어"},{"content":"Cartag 프로젝트 #4 # 오늘은 주말에도 팀원 분들과 모여서 프로젝트를 진행했다. 개발한 기능으로는 여러 상세 애니메이션과 추가 기능이다. 추가 기능으로 예산 설정바에 드래그 앤 드롭 기능을 넣었다. 마우스 커서를 그대로 있게 하느라 시간을 많이 썼다.\n구현 영상 # 코드 설명 # export default function PriceStaticBar({ ...props }: IPriceStaticBar) { const [startX, setStartX] = useState(0); const [startY, setStartY] = useState(0); const [offset, setOffset] = useState({ offsetX: \u0026#34;50%\u0026#34;, offsetY: \u0026#34;76px\u0026#34; }); const barRef = useRef\u0026lt;HTMLDivElement\u0026gt;(null); useEffect(() =\u0026gt; { window.addEventListener(\u0026#34;mousemove\u0026#34;, handleMouseMove); }); const handleMouseDown = (event: React.MouseEvent) =\u0026gt; { dragRef.current = true; const element = barRef.current!.getBoundingClientRect(); setStartX(event.clientX - element.left); setStartY(event.clientY - element.top); }; const handleMouseMove = (event: MouseEvent) =\u0026gt; { if (!dragRef.current) { window.removeEventListener(\u0026#34;mousemove\u0026#34;, handleMouseMove); return; } const minX = 0; const minY = 60; const maxX = window.innerWidth - (barRef.current?.offsetWidth || 0); const maxY = window.innerHeight - (barRef.current?.offsetHeight || 0); const newLeft = Math.min(Math.max(minX, event.clientX - startX), maxX); const newTop = Math.min(Math.max(minY, event.clientY - startY), maxY); setOffset({ offsetX: `${newLeft}px`, offsetY: `${newTop}px` }); }; const handleMouseUp = () =\u0026gt; { dragRef.current = false; }; handleMouseDown # 우선, handleDown은 커서로 예산 설정바를 잡을 때 실행되는 이벤트 핸들러이다. dragRef는 마우스가 드래그 이벤트를 실행해야 하는지를 알려준다. useState를 사용할 경우 렌더링 시에 값이 바껴서 false로 초기화가 돼서 useRef를 사용했다. dragRef.current 값을 true로 바꿔준다.\n또한 나중에 마우스 커서 위치를 기억하기 위해 startX, startY에다 각각의 statusBar 내에서의 위치를 기억해준다. barRef는 예산 설정바인데, barRef.current!.getBoundingClientRect();이렇게 해주면 그 요소까지의 위치 정보를 반환해준다.\nhandleMouseMove # dragRef.current가 true일 때에만 드래그 이벤트를 실행해준다. minX, minY, maxX, maxY는 화면에서 예산 설정바가 벗어나지 말아야 할 최솟값 범위이다. 이 때 마우스커서 위치를 그대로 해주기 위해 newLeft, newTop에 handleMouseDown에서 설정한 start 값을 각각 빼준다. (안 하면 점프 현상이 일어난다.)\nhandleMouseUp # 마우스 커서를 뗐다는 소리이다. (드롭과 의미 같음) 이 때에는 드래그 이벤트를 끝내야 하므로 dragRef.current값을 false로 설정해주면 된다.\nconst StatusBox = styled.div\u0026lt;{ $offset: IOffset; $isover: boolean; $isopen: boolean; }\u0026gt;` position: fixed; min-width: 343px; z-index: 1000; top: ${({ $offset }) =\u0026gt; $offset.offsetY}; left: ${({ $offset }) =\u0026gt; $offset.offsetX}; transform: ${({ $offset }) =\u0026gt; $offset.offsetX === \u0026#34;50%\u0026#34; ? \u0026#34;translateX(-50%)\u0026#34; : null}; (중략)cursor: pointer; `; 예산 설정바 스타일 컴포넌트에서 top, left 값을 state로 변경해주면 적용된다.\n이후 할 것 # 마우스 드래그 이벤트를 window로 줘서 그런가 드래그가 그 요소에도 된다. dragRef.current가 true일 경우에는 드래그를 방지할 수 있나 찾아 봐야겠다.\n","date":"13 August 2023","permalink":"/posts/cartag/%ED%94%84%EB%A1%9C%EC%A0%9D%ED%8A%B84/","section":"Posts","summary":"Cartag 프로젝트 #4 # 오늘은 주말에도 팀원 분들과 모여서 프로젝트를 진행했다.","title":"[Project] Cartag 프로젝트 #4"},{"content":"Hugo 블로그 자동화 # 오늘은 블로그 자동 배포를 해야지 해야지\u0026hellip; 생각만 하다가 드디어 실행에 옮겼다. 자동화를 하려고 검색을 하니까 크게 두 가지 방법이 있는 것 같았다. 1. Github Action을 이용한 방법과 2. Shell Script를 이용한 방법이 있었다. 주로 사람들이 전자를 쓰고 레퍼런스가 많은 것 같아 나도 전자를 선택했다.\nGithub Action? # 우선, 깃허브 액션에 대해 알아보자. 깃허브 액션은 Github에서 제공하는 CI/CD 솔루션이다. 유저는 uses 라는 명령어로 원하는 작업을 불러올 수 있다. 따라서 이번 포스팅에서는 Github Action 통해서 기존에 로컬에서 hugo 파일을 빌드해서 올리던 것을 Github Action을 통해 빌드하고 배포하도록 자동화했다. 이를 통해 블로그 포스팅용 레포지토리에 push만 하면 포스팅이 자동으로 배포된다!!\ngh-pages # npm의 gh-pages를 이용하면 깃허브를 통해 프로젝트가 변경될 때마다 자동으로 배포해준다.\n# gh-pages 패키지 설치 npm install -D gh-pages 해당 명령어를 블로그 프로젝트에서 실행해준다. 바보같이 이 명령어를 실행 안해줘서 자꾸 존재하지 않는다고 에러가 났다. ㅋㅋ.. 해당 브랜치명으로 생성도 해보고 하다가 다른 글보고 깨달았다. OTL\n# package.json { \u0026#34;devDependencies\u0026#34;: { \u0026#34;gh-pages\u0026#34;: \u0026#34;^6.0.0\u0026#34; }, \u0026#34;scripts\u0026#34;: { \u0026#34;build\u0026#34;: \u0026#34;webpack --mode production\u0026#34;, \u0026#34;predeploy\u0026#34;: \u0026#34;npm run build\u0026#34;, \u0026#34;deploy\u0026#34;: \u0026#34;gh-pages -d dist\u0026#34; } } 해당 명령어를 실행하면 프로젝트 아래에 package.json 파일이 생성되는데 위와 같이 수정하면 된다.\nGithub Action으로 hugo build 자동화 # 과정은 다음과 같다.\n1. 배포할 브랜치 설정 2. git checkout 을 통해 submodule, git contents를 pull 3. Github secrets 에 config.toml 파일을 저장 후 불러오기 4. hugo --minify 로 ./public 폴더에 내용 생성 5. google adsense를 위한 파일 삽입 6. github page용 repo에 파일 push 우선 블로그 포스팅이 올라가는 레포지토리에 .github/workflows/main.yml를 하나 생성한다. yml 확장자로만 되어 있으면 파일 이름은 상관없지만 경로는 매우*100 중요하다.\n최종 yml 파일 # name: github pages on: push: branches: - main # 1번 jobs: deploy: runs-on: ubuntu-20.04 steps: - uses: actions/checkout@v2 # 2번 with: submodules: recursive - name: copy config.toml # 3번 run: echo \u0026#34;${CONFIG_TOML}\u0026#34; \u0026gt; config.toml env: CONFIG_TOML: ${{ secrets.config }} - name: Setup Hugo uses: peaceiris/actions-hugo@v2 with: hugo-version: \u0026#34;latest\u0026#34; # extended: true - name: Build run: hugo --minify - name: site-verification # 5번 run: echo \u0026#34;${{ secrets.SITE_VERIFICATION }}\u0026#34; \u0026gt; ./public/google34bf590cfe76298c.html - name: Deploy # 6번 uses: peaceiris/actions-gh-pages@v3 with: deploy_key: ${{ secrets.ACTIONS_DEPLOY_KEY }} external_repository: kimdaye77/kimdaye77.github.io publish_branch: main publish_dir: ./public user_name: kimdaye77 user_email: kimdaye77@naver.com 키 생성 # 6번에서도 참 많은 우여곡절을 겪었다. deploy_key: ${{ secrets.ACTIONS_DEPLOY_KEY }}는 원하는 키 이름으로 해당 레포지토리 settings 아래 secrets에 있는 Actions에서 배포 키를 저장하면 된다. secrets 같은 경우는 비밀 키로 해야한다. # 키 생성 ssh-keygen -t rsa -C \u0026#34;이메일 주소\u0026#34; # 공개 키 cat ~/.ssh/id_rsa.pub # 비밀 키 cat ~/.ssh/id_rsa 결과 # 실패하면 위와 같이 어떤 부분에서 실패한 지 알려준다. 10트 넘게 한 끝에 성공!!\n회고 # 검색할 때 키워드를 Hugo, 자동화, Github Action 등으로 했는데 레퍼런스가 적었다. 나중에 보니 Hugo 키워드로 인해 결과가 적었던 것이었다\u0026hellip;!! 만약 자동화 할 일이 있거나 깃허브 액션을 쓸 경우는 Hugo 키워드는 제외하길.. 검색 결과가 많이 나와서 참고하기 좋다.\n이후 할 것 # 알아본 바로는 github에서 token을 통한 push만 허용되는 변경 등으로 인해 더이상 실행되고 있지 않은 듯? 2번의 과정에서 이 경우는 deprecated라고 떠서 수정해야 할 듯 싶다.\n","date":"12 August 2023","permalink":"/posts/create-blog/create-blog-automation/","section":"Posts","summary":"Hugo 블로그 자동화 # 오늘은 블로그 자동 배포를 해야지 해야지\u0026hellip; 생각만 하다가 드디어 실행에 옮겼다.","title":"Hugo 블로그 제작기 - 자동화"},{"content":"","date":null,"permalink":"/categories/%EB%B8%94%EB%A1%9C%EA%B7%B8-%EC%A0%9C%EC%9E%91/","section":"Categories","summary":"","title":"블로그 제작"},{"content":"","date":null,"permalink":"/tags/%EB%B8%94%EB%A1%9C%EA%B7%B8-%EC%A0%9C%EC%9E%91%EA%B8%B0/","section":"Tags","summary":"","title":"블로그 제작기"},{"content":"Context API # 오늘은 Context API라는 주제에 대해 다뤄보겠다. 이번 프로젝트 Cartag에서 Redux 사용이 금지되어서 대신 사용하는 기술이다.(엄밀히 말하면 둘은 다른 목적을 가진 기술이다.) 이번 기회를 통해 알게 되었다.\nContext API란? # 우선, Context API는 쉽게 말하면 전역 상태이다. 리액트에서는 상태 관리를 하기 위해서 useState 훅을 사용한다. 이 상태는 사용한 컴포넌트 내에서만 사용 가능하고 다른 컴포넌트에게 전달을 하기 위해서는 props를 통해 전달을 해주어야 하는데, 이는 보통 하향식으로 일어난다. 이러한 특성 탓에 한 단계 아래의 자식이 아니라, 몇 단계를 뛰어 넘는 자식에게 속성 값을 전달하고 싶거나 얽히고 섥힌 관계가 있을 경우\u0026hellip; props drilling 문제가 생기고 복잡해진다! Props Drilling # 이름에서부터와 리액트로 개발을 해 본 사람들은 Props drilling이라는 단어에서부터 무슨 의미인지 직감할 것이다. 이러한 Props drilling 문제를 해결하기 위한 기술이 지금 기술하는 Context API이다.\n위애서 서술했듯이 props drilling 하위 컴포넌트에게 전달해주기 위해 props를 계속 아래로 전달해줘야 하는 문제이다.\n코드 예시 # export default function App() { return ( \u0026lt;div className=\u0026#34;App\u0026#34;\u0026gt; \u0026lt;FirstComponent content=\u0026#34;Who needs me?\u0026#34; /\u0026gt; \u0026lt;/div\u0026gt; ); } function FirstComponent({ content }) { return ( \u0026lt;div\u0026gt; \u0026lt;h3\u0026gt;I am the first component\u0026lt;/h3\u0026gt;; \u0026lt;SecondComponent content={content} /\u0026gt;| \u0026lt;/div\u0026gt; ); } function SecondComponent({ content }) { return ( \u0026lt;div\u0026gt; \u0026lt;h3\u0026gt;I am the third component\u0026lt;/h3\u0026gt;; \u0026lt;ComponentNeedingProps content={content} /\u0026gt; \u0026lt;/div\u0026gt; ); } function ComponentNeedingProps({ content }) { return \u0026lt;h3\u0026gt;{content}\u0026lt;/h3\u0026gt;; } 위와 같이 몇 단계 아래의 컴포넌트에게 content라는 값을 전달해주고 싶으면 props를 순차적으로 자식에게 전달해야 한다..\nexport default function App() { const content = \u0026#34;Who needs me?\u0026#34;; return ( \u0026lt;div className=\u0026#34;App\u0026#34;\u0026gt; \u0026lt;FirstComponent\u0026gt; \u0026lt;SecondComponent\u0026gt; \u0026lt;ComponentNeedingProps content={content} /\u0026gt; \u0026lt;/SecondComponent\u0026gt; \u0026lt;/FirstComponent\u0026gt; \u0026lt;/div\u0026gt; ); } function FirstComponent({ children }) { return ( \u0026lt;div\u0026gt; \u0026lt;h3\u0026gt;I am the first component\u0026lt;/h3\u0026gt;; {children} \u0026lt;/div\u0026gt; ); } function SecondComponent({ children }) { return ( \u0026lt;div\u0026gt; \u0026lt;h3\u0026gt;I am the third component\u0026lt;/h3\u0026gt; {children} \u0026lt;/div\u0026gt; ); } function ComponentNeedingProps({ content }) { return \u0026lt;h3\u0026gt;{content}\u0026lt;/h3\u0026gt; 원래라면 props를 계속 전달해야 했지만 Context API를 쓰면 전역 상태처럼 Context Tree는 컨텍스트 안에 포함된 모든 레벨에서 명시적으로 prop 을 전달하지 않고, 어디서든 상태값에 접근 할 수 있는 방법을 제공한다. 따라서 prop-passing 로직을 작성할 필요가 없기 때문에 코드가 단순해진다.\nContext API vs Redux # 나는 처음에 Redux와 개념이 헷갈렸다. 하지만 두 기술은 목적이 다르다. Context API만 검색해도 연관 검색어에 vs Redux가 나온 만큼 두 기술 모두 전역 상태로는 둘 다 사용할 수 있다. 하지만 내가 이해한 바로는 다음과 같다.\nContext API # Provider와 Consumer의 관계 같이 제공하고 소비하는 개념\nRedux # Publish Subscribe 개념도 포함 옵저버 패턴처럼 상태 변화를 목적에 두는 기술\n실제로 크롬 확장 도구에 있는 Redux Devtool 프로그램에서는 이러한 리덕스의 특성을 통해 디버깅 할 수 있는 것을 보아 이 부분의 특성이 매우 강한 것 같다!!\n","date":"11 August 2023","permalink":"/posts/frontend/context-api/","section":"Posts","summary":"Context API # 오늘은 Context API라는 주제에 대해 다뤄보겠다.","title":"[FE] Context API"},{"content":"","date":null,"permalink":"/tags/%ED%94%84%EB%A1%A0%ED%8A%B8%EC%97%94%EB%93%9C/","section":"Tags","summary":"","title":"프론트엔드"},{"content":"","date":null,"permalink":"/categories/%ED%94%84%EB%A1%A0%ED%8A%B8%EC%97%94%EB%93%9C/","section":"Categories","summary":"","title":"프론트엔드"},{"content":"useRef # 오늘은 useRef라는 리액트 훅에 대해서 알아보겠다. 저번 FE-NEWSSTAND 프로젝트에서는 DOM API를 많이 사용했었다. DOM API로는 querySelector, getElementById등이 있다. 해당하는 api를 써서 찾고 싶은 클래스 이름이나 아이디를 써서 html 요소를 바꿀 수 있었다.\n하지만 이번 Cartag 프로젝트는 styled-components를 사용하기 때문에 클래스 이름이 브라우저가 렌더링될 때 랜덤으로 지정된다.(중복 방지)\n따라서 DOM API를 사용하기 힘든데 이를 위해 리액트는 useRef라는 훅 기능을 지원해준다. 이를 통해 특정 엘리먼트의 크기, 스크롤바 위치 등 다양한 것들을 설정할 수 있다. 우선 프로젝트에서 사용한 예시로 자세히 알아보겠다.\n실제 적용 예시 # 코드 #1 # import { useRef } from \u0026#34;react\u0026#34;; const tabDivisionRef = useRef\u0026lt;HTMLDivElement\u0026gt;(null); useEffect(() =\u0026gt; { if (tabDivisionRef.current) { const tabDivisionWidth = tabDivisionRef.current.offsetWidth; setTabDivisionWidth(tabDivisionWidth); } }, [tabDivisionRef]); return ( \u0026lt;TabWrapperInner ref={tabDivisionRef}\u0026gt; \u0026lt;Tab $offset={page * -tabDivisionWidth}\u0026gt;(중략)\u0026lt;/Tab\u0026gt; \u0026lt;/TabWrapperInner\u0026gt; ); 우선, 위와 같이 다른 리액트 훅처럼 import를 해준다. 그리고 변수에다가 useRef를 통해 ref 객체를 만든다. 이후 return문에서 지정할 DOM을 찾아(스타일 컴포넌트) ref 객체에 설정해준다. {ref 객체}.current값은 우리가 원하는 DOM을 가리키게 된다!!\n위의 예시는 tabDivisionRef에 저장한 ref 객체의 offsetWidth값(엘리먼트의 width)이 바뀔 때마다 setTabDivisionWidth(tabDivisionWidth) 코드로 상태를 업데이트 하는 코드이다.\n코드 #2 # const hmgDataBgRef = useRef\u0026lt;HTMLDivElement\u0026gt;(null); const handleClick = (event: MouseEvent) =\u0026gt; { if (guideBubbleRef.current?.contains(event.target as Node)) { return; } if (hmgDataBgRef.current?.contains(event.target as Node)) { return; } setDisplayDimmed(false); }; 이번에는 {ref 객체}.current.contains()를 통해 hmgDataBgRef로 DOM 요소를 참조하고 클릭 이벤트가 발생했을 때 해당 요소의 안에 있는지 여부를 확인하여 setDisplayDimmed 상태를 변경하는 예시이다.\n이외의 다른 사용 예시 # useRef 안에 변수 넣기 # const renderingCount = useRef(1); useState와 달리 useRef로 관리하는 값은 값이 변해도 화면이 렌더링되지 않는다. 따라서 이러한 특성을 이용해서 컴포넌트 렌더링 횟수 등을 알 수 있다고 한다.\n개인적인 소견 # 위처럼 유용한 기능이 많지만 이때까지 DOM API를 많이 사용해서 그런가 약간 불편하다. 어떤 점이 불편하냐면 useRef는 한 컴포넌트 내에서는 DOM 관리에 무척이나 용이하지만 다른 컴포넌트의 DOM을 가져오는 건 익숙하지 않아서 불편하다. 하지만 유용하다는 점은 틀림없고, 지금과 같이 스타일 컴포넌트를 사용하는 경우에는 useRef는 없어서는 안되는 중요한 훅인 것은 분명하다.\n","date":"10 August 2023","permalink":"/posts/frontend/useref/","section":"Posts","summary":"useRef # 오늘은 useRef라는 리액트 훅에 대해서 알아보겠다.","title":"[FE] 리액트 훅 - useRef"},{"content":"","date":null,"permalink":"/tags/%EB%A6%AC%EC%95%A1%ED%8A%B8%ED%9B%85/","section":"Tags","summary":"","title":"리액트훅"},{"content":"CSS # 오늘은 Cartag 프로젝트에서 position 속성 중 sticky를 사용해봤다.\nsticky는 최근에 추가된 속성으로 fixed와 static의 속성을 정한 값에 따라 적용할 수 있는 좋은 기술이다.\n요즘에는 참 좋은 기술이 많이 생긴 것 같다.\nPosition # position 속성은 html 태그의 위치를 정할 수 있으며 여러 가지 속성값이 있다.\n# 사용법 position: {원하는 속성값} # 예시 #box1 { position:inherit } #box2 { position:static } #box3 { position:absolute } #box4 { position:relative } #box5 { position:fixed } #box6 { position:sticky } 속성값으로는 다음과 같이 있다.\nstatic # 기본값이다. 다른 요소와의 관계에 의해 auto로 배치된다. 좌표를 설정할 수 없다.\ninherit # 부모 요소의 태그 속🕊️성값을 상속받는다.\nabsolute # 부모 요소를 relative로 주고 본인(자식)을 position: absolute와 top, bottom, left, right 좌표를 지정해주면 절대 좌표로 위치를 지정할 수 있다. absolute 속성 값은 아래의 relativ와 자주 쓰인다. 겹치는 요소일 때 많이 사용한다.\nrelative # 원래 있던 위치를 기준으로 좌표를 지정한다.\nfixed # 스크롤에 관계 없이 좌표를 고정한다. Nav 바 같은 곳이나 Footer에 많이 쓰인다.\n# 예시 position: fixed; top: 0px; left: 0px; z-index: 999; //구구구..🕊️ sticky # static과 fixed가 섞인 느낌! 원래는 static하게 존재하다가 스크롤시 지정 지점에서 요소를 고정시킨다.\n# sticky 사용 시 주의점 1. sticky 속성을 갖는 요소의 부모 태그에 height이 지정되어 있어야 한다. (부모 height 높이 값만큼 고정된다.) 2. 부모요소중에 overflow: hidden, auto, scroll 속성이 적용되어 있으면 안된다. 적용 영상 # 나는 top: {원하는 높이px}만큼 줬기 때문에 영상에서 보다 싶이 저 픽셀까지는 스크롤 되다가(static 속성) 이후로는 fixed 속성과 같이 고정된 곳에 위치하도록 동작한다. sticky는 영상이나 그림으로 보는 것이 이해가 쉽다.\n","date":"9 August 2023","permalink":"/posts/frontend/css-position/","section":"Posts","summary":"CSS # 오늘은 Cartag 프로젝트에서 position 속성 중 sticky를 사용해봤다.","title":"[FE] CSS-position 속성"},{"content":"Routing # 오늘은 라우팅에 관한 수업을 들었다. 라우팅과 관련해서 이야기하면서 SPA(Single Page Applications)와 history api에 대해서도 공부하였다. 현재 지금 개발중인 프로젝트(Cartag)이 SPA로 구현하고 있기 때문에 라우팅은 굉장히 중요한 개념이다. 오늘 배운 내용을 정리하겠다.\nSPAs? # 먼저 SPA란 Single Page Application의 줄임말이다. 대부분의 웹사이트는 MPA(Multiple Page Application)으로 되어있다. 하지만 최근들어 SPA로 개발하는 것이 트렌드인 듯 싶다. 이렇듯 SPA로 개발하면 어떤 특징이 있는지 알아보자.\nSPA 특징 # 우선, SPA는 모든 정적 리소스를 초기에 로딩한다. 따라서 페이지 간 이동 시, 페이지 갱신에 필요한 데이터만을 JSON으로 전달받는다는 것이 가장 큰 특징이다.\nSPA는 React에서 Router를 통해 구현할 수 있다.\nRouter # SPA에서 routing은 사용자가 쉽게 navigate할 수 있게끔 도와준다. 왜냐하면 SPA는 하나의 페이지를 보여주지만 주소에 따라 각기 다른 페이지를 보여주기 때문이다. 주소에 따라서 보여지는 화면이 달라지게 해주는 기술을 리액트에서 Routing을 통해 지원해준다.\nhistory API # history API는 브라우저의 세션 history를 관리할 수 있는 메소드를 담고 있는 객체이다. 이를 이용해서 뒤로 가기 및 페이지 이동을 할 수 있다.\n# history API 메소드 history.back(); // 뒤로 history.forward(); // 앞으로 history.go(); // 새로고침 history.go(-1); // 뒤로 history.go(1) // 앞으로 # html5부터 추가된 메소드 history.pushState({데이터 객체}, title, page) history.replaceState({데이터 객체}, title, page) history 비교 # 카카오 맵: 히스토리는 쌓이는데 상태 관리가 안 된다. 구글 맵: 히스토리도 쌓이고 상태 관리 된다. =\u0026gt; 쿠팡 사이트 때부터 느낀건데 대기업이 개발한 페이지여도 ux가 별로인 것이 상당히 많았다.\n","date":"8 August 2023","permalink":"/posts/frontend/routing/","section":"Posts","summary":"Routing # 오늘은 라우팅에 관한 수업을 들었다.","title":"[FE] 라우팅"},{"content":"CSS # 오늘은 무엇에 관해 블로그 글을 정리할지 많은 고민을 했다. 고민 끝에 내린 결론은 CSS이다. 따라서 이번 공부의 주제는 CSS이다. 사실 나는 깡 css를 주로 사용을 해보았고(굳이 썼다면 부트스트랩이나 material) 이번 프로젝트를 진행하면서 styled-components를 처음 사용해보았다. 사용하고서 재사용성, 유지보수성 등의 면에서 너무 흡족했고 이에 따라 Tailwind CSS라던가 SCSS 등 css 사용을 돕기 위한 다른 스타일 라이브러리 및 프레임워크에 관해서도 알고 싶었다.\nCSS란? # CSS는 기본적으로 HTML의 스타일링을 위한 라이브러리이다. CSS의 사용을 돕기 위한 여러가지 라이브러리나 프레임워크들이 많이 지원된다. 아래의 사진은 만족도와 사용도 Sass # Syntactically Awesome Style Sheets\n앞글자를 따서 Sass라고 한다. Sass는 SASS, SCSS 문법이 있다. 기능은 같지만 아래 사진처럼 문법이 약간씩 차이가 있다. SASS는 identation(들여쓰기)과 newline을 사용하고 SCSS는 curly braces(중괄호)와 semicolon을 사용한다.\nTailwind CSS # Atomic CSS\n여러 css 의 조합으로 하나의 스타일링을 정의하는 방식과 반대로 Tailwind 는 css 들을 모조리 분해하여 사용자가 자유롭게 조합할 수 있도록 만들었다. 최근 인기와 관심도가 높은 기술 중 하나라고 한다. 더 자세히 말하자면, 모두 같은 specificity class로 구성되어 CSS의 관리와 네이밍을 위한 고민이 필요하지 않다고 한다.\nCSS Modules # CSS-in-CSS\nCSS 파일에 선언한 클래스명이 자동 변경되어 중복을 신경쓰지 않아도 되며, 전체 페이지의 CSS를 렌더링 시 한 번에 로드한다.\nStyled-component # CSS-in-JS\n한 마디로 스타일을 가진 컴포넌트를 정의해서 사용할 수 있다. CSS를 JS를 통해 만들어서 return 구문은 semantic한 컴포넌트들로만 구성되어 있어 가독성 좋은 코드를 만들 수 있다. 컴포넌트로 전달하는 값(JS 함수, 값 공유)에 따라 동적으로 스타일 적용 가능하다. JS 런타임 과정에서 동적인 클래스명을 생성해준다. 정말 좋은 점은 클래스명이나 id명을 랜덤으로 자동 생성해주기 때문에 중복이 발생할 일이 없다. 하지만 CSS 구문 분석 과정이 필요해서 렌더링 속도가 느리다.\n소견 # Sass 보면서 Sass에서 문법은 SASS보다는 SCSS가 편한 것 같다. 파이썬 개발자는 전자가 편할지도 모르지만 나는 주로 개발 언어가 c언어나 js쪽이기 후자가 편하다.\nTailwind CSS Tailwind CSS는 진짜 방법이 달라서 감이 잡히지도 않는다.\nCSS Modules vs Styled Component 이 둘의 특징이 정말 상반돼서 신기했다. 지금 Styled-component를 사용하고 있으므로 다른 특징을 지닌 Css Modules로도 개발을 진행해보면 둘의 특징을 확실하게 알 수 있을 것 같다.\n","date":"6 August 2023","permalink":"/posts/frontend/css/","section":"Posts","summary":"CSS # 오늘은 무엇에 관해 블로그 글을 정리할지 많은 고민을 했다.","title":"[FE] CSS 라이브러리와 프레임워크"},{"content":"CS 스터디 # 갑자기 CS 스터디 포스팅을 하게 된 이유는 다음과 같다. 8월 5일에 약속이 있음. 개발할 시간이 없어서 공부 개념 정리로 포스팅하고자 함. 같은 팀원 분들 중 백엔드 분께서 면접 대비로 열심히 CS공부를 하는 것이 생각나서 결심하게 됨. 위의 절차가 나의 결심 과정이다. 하하.\n전에 회사 면접 관계자님의 말씀을 들었을 때, 다들 비슷한 개발 경험을 가졌으면 CS쪽에서 많이들 변별을 한다고 한다. ++ 슬슬 수강신청할 때가 돼서 공부 머리를 돌려놔야겠다. 오늘은 블로그 댓글 기능을 구현하면서 사용한 local storage와 그와 관련된 저장소들에 대해서 정리하겠다.\nWEB Storage # Web Storage는 key, value 쌍으로 데이터를 저장하고 조회할 수 있게 해준다. 데이터의 지속성에 따라 영구저장소(LocalStorage)와 임시저장소(SessionStorage)가 있다.\nLocal storage # 저장한 데이터를 명시적으로 지우지 않는 이상 영구적으로 보관이 가능하다. Session Storage는 웹페이지의 세션이 끝날 때 저장된 데이터가 지워지는 반면에, Local Storage는 웹페이지의 세션이 끝나더라도 데이터가 지워지지 않는다.\n즉, 브라우저에서 같은 웹사이트를 여러 탭이나 창에 띄우면, 여러 개의 세션 스토리지에 데이터가 서로 격리되어 저장된다. 따라서 각 탭이나 창이 닫힐 때 저장해 둔 데이터도 함께 소멸한다. 반면에, 로컬 스토리지의 경우 여러 탭이나 창 간에 데이터가 서로 공유되고 탭이나 창을 닫아도 데이터는 브라우저에 그대로 남아 있다. 도메인만 같으면 데이터를 사용할 수 있는 것이다.\nSession Storage # Session Storage는 위에서 말했다싶이 데이터가 지속적으로 보관되지 않는다. 이러한 특징은 후술할 세션 쿠키와 비슷하다. 따라서 Session Storage의 가장 큰 특징은 현재 페이지가 브라우징되고 있는 브라우저 컨텍스트 내에서만 데이터가 유지된다는 것이다. Local Storage는 브라우저를 종료해도 데이터는 보관되어 다음번 접속에도 그 데이터를 사용할 수 있지만 SessionStorage는 브라우저가 종료되면 데이터도 같이 지워진다. 즉, 브라우저가 종료되면 Session Storage도 삭제된다.\n기본 API\n# 사용 예시 // 키에 데이터 쓰기 localStorage.setItem(\u0026#34;key\u0026#34;, value); // 키로 부터 데이터 읽기 localStorage.getItem(\u0026#34;key\u0026#34;); // 키의 데이터 삭제 localStorage.removeItem(\u0026#34;key\u0026#34;); // 모든 키의 데이터 삭제 localStorage.clear(); // 저장된 키/값 쌍의 개수 localStorage.length; set이랑 get만 써봤는데 length 기능도 있는지는 오늘 공부하면서 알았다.\nWEB Storage vs Cookie # Web Storage는 기존 웹 환경의 쿠키(Cookie)와 비교할 수 있다. Web Storage가 최신 기술로 쿠키의 몇 가지 단점을 개선했다. 두 개념의 차이는 다음과 같다. 개인적으로 차이만 보면 쿠키보다 Web Storage가 좋은 것 같지만 둘 다 자주 쓰이는 것 같다.\n서버 전송 여부 # 웹 사이트에서 쿠키는 매번 서버로 전송된다. 그에 반해 Web Storage는 서버로 전송이 이루어지지 않는다. 저장된 데이터는 클라이언트에 존재한다. 이런 점에서 네트워크 트래픽 비용 감소의 효과가 있다.\n데이터 타입 및 용량 # Web Storage는 문자열 기반의 쿠키와 달리 문자열에 제한되지 않고 객체를 저장할 수 있다. 또한 쿠키는 한 사이트에서 최대 20개, 4KB만 저장할 수 있다. 그러나 Web Storage에는 이러한 제한이 없다. 그리고 영구 데이터 저장이 가능하다.\n개발자 도구 # 데이터는 개발자 도구를 켜서 애플리케이션 탭을 선택해서 아래의 화면과 같이 볼 수 있다. 위에서 appearance라는 키에 현재 값 light가 저장되어 있는데 이는 내가 지금 라이트 모드로 설정했기 때문이다. 아래의 다크 모드 아이콘을 클릭하면 로컬 스토리지의 데이터각 변경되어 저장된다. 이는 내가 브라우저를 종료해도 그대로 설정 값이 남아 있는다.\n","date":"5 August 2023","permalink":"/posts/cs-study/cs-study1/","section":"Posts","summary":"CS 스터디 # 갑자기 CS 스터디 포스팅을 하게 된 이유는 다음과 같다.","title":"[CS] CS 공부 #1"},{"content":"","date":null,"permalink":"/tags/cs/","section":"Tags","summary":"","title":"CS"},{"content":"","date":null,"permalink":"/categories/cs-%EA%B3%B5%EB%B6%80/","section":"Categories","summary":"","title":"CS 공부"},{"content":"","date":null,"permalink":"/tags/%EB%A9%B4%EC%A0%91%EB%8C%80%EB%B9%84/","section":"Tags","summary":"","title":"면접대비"},{"content":"Hugo 댓글 제작 # 댓글 기능 제작 결심 # 크롱님께서 쉬는 시간을 주셔서 오늘 고시원으로 간소한 이사(?)를 하기 때문에 힘들 것 같아서 블로그 글을 미리 쓰려고 했다. 어떠한 계기였는지는 모르겠지만 댓글 기능에 대해 생각하다가 다시 테마 설명을 보게 되었다. 처음 블로그 제작할 때에도 느꼈으나 본인이 사용하는 테마의 docs를 정독하자. 정말 친절하다 ^v^ bb\n테마 설명을 보니 정말 간단했다. params.toml에서 showComments의 값을 기본 값인 false에서 true로 설정하고(각 포스팅마다 댓글 표시 여부를 다르게 하고 싶으면 전체 매개 면수 말고 각 포스팅마다 설정해주면 된다.)\n이후, layouts 폴더 아래에 partials/comments.html을 제작하고 여기 부분은 Hugo Docs를 참고하라고 되어있었다. ⚠️ 각 테마마다 폴더 구조가 다르므로 본인의 테마 문서를 꼭 확인할 것\nDisqus # Hugo Docs에서는 disqus 사용을 권장하나, 여러 글을 봤을 때 disqus보다는 utterances가 여러모로 좋은 것 같았다.\ndisqus는 무료 라이센스로 사용하는 경우 광고가 생긴다. (이게 내가 생각하는 가장 큰 단점 같다. 광고 하나도 아니고 ux를 정말 해치는 다수의 광고가 보여진다\u0026hellip;.) disqus보다 utterances를 개발자들이 많이 사용한다. disqus보다 utterances가 가볍다. ++ 이후 알게된 것인데 이슈랑 연결되어 있어서 댓글이 달리면 알림도 온다. 근데 댓글을 다려면 깃허브 로그인을 해야 한다. Utterances를 사용한 댓글 기능 구현 # 과정 # 나는 새로 레포지토리를 만들었다. 댓글용 레포지토리 주의할 점은 Public으로 해야 한다. (++ 나중에 배포하고 안 보여서 뭐지?? 했는데 배포하는 페이지 github.io와 블로그 포스트용 레포지토리에도 설치를 해야한다!!)\n사용할 레포지토리에 utterances 설치가 끝나면 (https://utteranc.es/)에서 설정을 다하면 스크립트를 복사해서 자신의 코드에 붙여넣기를 하면 된다.\n다크 모드 여부에 따라 theme 설정 변경 # 이건 gpt와 나의 합작이다. Hugo 자체가 한글 레퍼런스가 많이 없기도 하고, 다들 다크 모드 구현은 안하고 하나의 theme만 설정했다. 하지만 나는 주위에 다크모드에 예민한 사람들이 많아서 댓글 theme에 다크모드 기능을 부여하고 싶었다.\n완성 # 코드 # \u0026lt;script src=\u0026#34;https://utteranc.es/client.js\u0026#34; repo=\u0026#34;kimdaye77/Blog-comments\u0026#34; issue-term=\u0026#34;pathname\u0026#34; theme=\u0026#34;github-light\u0026#34; crossorigin=\u0026#34;anonymous\u0026#34; async \u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script\u0026gt; const currentAppearance = localStorage.getItem(\u0026#34;appearance\u0026#34;); const regex = /^Switch.*appearance$/; document.addEventListener(\u0026#34;click\u0026#34;, function (event) { const targetButton = event.target.closest(\u0026#34;div\u0026#34;); if (targetButton \u0026amp;\u0026amp; regex.test(targetButton.title)) reloadUtterances(); }); // Utterances 다시 로드 함수 function reloadUtterances() { const utterancesContainer = document.querySelector(\u0026#34;.utterances\u0026#34;); utterancesContainer.innerHTML = \u0026#34;\u0026#34;; // 기존 Utterances 컨테이너 비우기 // 새로운 스크립트 엘리먼트 생성 const newScript = document.createElement(\u0026#34;script\u0026#34;); newScript.src = \u0026#34;https://utteranc.es/client.js\u0026#34;; newScript.setAttribute(\u0026#34;repo\u0026#34;, \u0026#34;kimdaye77/Blog-comments\u0026#34;); newScript.setAttribute(\u0026#34;issue-term\u0026#34;, \u0026#34;pathname\u0026#34;); newScript.setAttribute( \u0026#34;theme\u0026#34;, localStorage.getItem(\u0026#34;appearance\u0026#34;) === \u0026#34;dark\u0026#34; ? \u0026#34;github-dark\u0026#34; : \u0026#34;github-light\u0026#34; ); newScript.setAttribute(\u0026#34;crossorigin\u0026#34;, \u0026#34;anonymous\u0026#34;); newScript.setAttribute(\u0026#34;async\u0026#34;, true); // Utterances 컨테이너에 새로운 스크립트 엘리먼트 추가 utterancesContainer.appendChild(newScript); } // 페이지 로드 시 localStorage 값을 확인하여 초기 테마 설정 window.onload = function () { reloadUtterances(); }; \u0026lt;/script\u0026gt; 댓글 화면 # 같은 팀원분한테 테스트를 부탁했다. 확인 결과 잘 작동한다. ++ 다크모드 기능이 잘 되는지 확인하려고 여러 번 클릭했는데 새로운 에러메시지를 발견했다.\nutterances.6ec01640.js:1 Uncaught (in promise) Error: Error fetching issue via search. Failed to load resource: the server responded with a status of 429 () gpt 덕분에 위의 에러 발생 원인을 알아냈다.\n서버로부터 너무 많은 요청을 받아들여 처리하지 못했을 때 발생하는 오류입니다. 이 오류는 서버에서 설정한 요청 제한을 초과하면 발생합니다.\n라고 한다. 이 문제는 주로 Utterances 스크립트가 사용하는 GitHub API와 관련이 있다. Utterances 스크립트는 GitHub API를 사용하여 댓글을 가져오고 게시한다. GitHub는 남용을 방지하고 공정한 사용을 보장하기 위해 API 요청에 대해 요청 제한을 설정한다. Utterances 컴포넌트를 반복적으로 로드하거나 다시 로드하면 요청 제한을 초과하여 429 오류가 발생할 수 있다고 한다.\n향후 계획 # 요청 제한도 기능 구현해야겠다. 자동 배포랑 도메인 적용도 해야하는데.. 언제하지\n","date":"4 August 2023","permalink":"/posts/create-blog/create-blog-comments/","section":"Posts","summary":"Hugo 댓글 제작 # 댓글 기능 제작 결심 # 크롱님께서 쉬는 시간을 주셔서 오늘 고시원으로 간소한 이사(?","title":"Hugo 블로그 제작기 - 댓글편"},{"content":"Cartag 프로젝트 #3 # 오늘은 제너럴 컴포넌트를 예산 초과 여부에 따라 박스 내의 텍스트와 색상을 바꿔주었다. 또한 설정한 예산의 마커 UI를 추가해주었다.\n구현 영상 # 어려웠던 점 # 설정한 예산 값의 현재 지점 표시하는 마커가 슬라이드 바의 핸들을 가려서 겹칠 경우, 클릭이 안먹는 버그가 있었다. 하지만 같은 팀원분께서 CSS 이벤트 제어 pointer-events 속성을 사용해서 none 값을 적용하면 마커의 클릭 이벤트를 제거할 수 있다고 알려주셔서 해결할 수 있었다.\n시행착오 # z-index # z-index를 줘봤는데 핸들이 클릭 이벤트가 가능하도록 하기 위해 높은 값을 부여하면 마커가 슬라이드 바 뒤에 가서 이 방법은 기각되었다.\npointer-events # 팀원 분께서 알려주셔서 해결한 방법이다!\npointer-events 는 HTML 요소들의 마우스/터치 이벤트들(CSS hover/active, JS click/tap, 커서 드래그등)의 응답을 조정할 수 있는 속성이다.\nnone : HTML 요소에 정의된 클릭, 상태(hover,active등), 커서 옵션들이 비활성화한다. auto : 비활성화된 이벤트를 다시 기본 기능을 하도록 되돌린다. inherit : 부모 요소로부터 pointer-events 값을 상속받는다. 나의 경우에는 none 값을 적용해서 클릭 커서 옵션을 비활성화했다.\n따라서 마커와 핸들이 겹쳐있더라도 마커는 클릭이 안 되도록 했기 때문에 뒤에 있는 핸들의 클릭 이벤트가 가능하게 되었다.\n코드 # # PriceStaticBar.tsx const MarkerSvg = styled.svg\u0026lt;{ $isover: boolean; $percent: number }\u0026gt;` pointer-events: none; position: absolute; width: 9px; height: 23px; top: 6px; fill: ${(props) =\u0026gt; props.$isover ? props.theme.color.sand : props.theme.color.primaryColor400}; left: ${(props) =\u0026gt; props.$percent}%; transform: translate(-50%, -50%); `; 또한 중요한 점은 pointer-events 속성은 11개의 속성값을 가지지만 3개를 제외하고는 모두 SVG에서 사용하도록 예약되어 있다. 아래의 3개의 속성값은 HTML 요소들에서 사용 가능하다.라는 것인데 마침 마커가 svg라 가능했다.\n마치며 # 이후의 계획으로는 백엔드 팀원분들과 협력해서 배포를 할 계획인데 기대가 된다!\n","date":"3 August 2023","permalink":"/posts/cartag/%ED%94%84%EB%A1%9C%EC%A0%9D%ED%8A%B83/","section":"Posts","summary":"Cartag 프로젝트 #3 # 오늘은 제너럴 컴포넌트를 예산 초과 여부에 따라 박스 내의 텍스트와 색상을 바꿔주었다.","title":"[Project] Cartag 프로젝트 #3"},{"content":"Cartag 프로젝트 #2 # 오늘은 제너럴 컴포넌트를 구현했다. 개발하면서 새로운 것들을 많이 알게 됐는데 그 중 두 가지를 소개하겠다.\nInput 태그 타입 # input은 항상 form 제출 입력용으로 text만 사용했는데 이번에 슬라이드 마커를 구현하게 되면서 새로 알게 된 쓰임이 있다.\n바로 type을 range로 설정하면 슬라이드 바를 조정하여 범위 내의 숫자를 선택할 수 있는 입력 필드가 생성된다! 이외의 type의 종류는 무엇이 있을까 궁금해서 더 찾아보았다.\ntype의 종류 # Text // 텍스트 입력 필드 Radio // 라디오 박스 (단일 선택) CheckBox // 체크 박스 (다중 선택) Submit // 폼 양식 제출 Button // 버튼 Reset // 폼 초기화 File // 파일 선택 Date // 날짜 정보 입력 Number // 숫자 정보 입력 Email // 이메일 형식 입력 Color // 색상 선택 Range // 슬라이드 바 Search // 검색 바 Select-box // 옵션 선택 가능 위와 같이 많은 기능을 지원해준다.\n실제 사용 예시 # const PriceBar = styled.input.attrs((props) =\u0026gt; ({ type: props.type, min: props.min, max: props.max, value: props.value, onChange: props.onChange, }))` -webkit-appearance: none; width: 330px; height: 6px; border-radius: 10px; background: ${(props) =\u0026gt; props.theme.color.white}; outline: none; /* 슬라이더 배경 색상 */ \u0026amp;::-webkit-slider-runnable-track { width: 100%; height: 100%; background: ${(props) =\u0026gt; props.theme.color.primaryColor800}; border-radius: 10px; } /* 슬라이더 핸들 스타일 */ \u0026amp;::-webkit-slider-thumb { appearance: none; width: 20px; height: 20px; background: ${(props) =\u0026gt; props.theme.color.primaryColor400}; border-radius: 50%; cursor: pointer; border: 1px solid #fff; margin-top: -8px; } `; 아직 커스텀은 미완이다. 하지만 드래그에 따라 값이 변하도록 onChange 핸들러는 구현 완료했다.\n위의 그림과 같이 슬라이드로 값을 변경할 수 있다.\nuseId # useId는 리액트 훅 중 하나이다. 이름에서 알다싶이 고유한 id를 자동으로 생성해주는 기능을 한다. 사용법은 기존의 훅 사용법과 동일하다.\n사용법 # # 사용 예시 import React, { useId } from \u0026#34;react\u0026#34;; const id = useId(); useId 훅을 import 해주고 변수에 저장하고 나중에 사용하면 된다. 간단!\n하지만 주의점이 있다.\n주의할 점 # CSS selector 사용 X 변경해서는 안 되는 값에는 사용 X ","date":"2 August 2023","permalink":"/posts/cartag/%ED%94%84%EB%A1%9C%EC%A0%9D%ED%8A%B82/","section":"Posts","summary":"Cartag 프로젝트 #2 # 오늘은 제너럴 컴포넌트를 구현했다.","title":"[Project] Cartag 프로젝트 #2"},{"content":"Cartag 프로젝트 #1 # 오늘부터 본격적으로 개발에 들어간다. 🐜 두둥! 탁\n개발에 들어가기 앞서 초기 개발 환경 세팅과 프로젝트 색상, 폰트들을 정의했다.\n빠른 시간 내에 완료하고 개발할 줄 알았으나\u0026hellip;\nVite # 우선 크롱님께서 CRA(Create React App)보다는 Vite을 추천한다고 하셨다. 나는 이게 무엇인지 몰랐으나 팀원 분이 알아서 초기 개발 환경 세팅은 수월했다. 집에 와서 따로 공부하는 시간을 가지고 정리해본다.\n핵심만 말하자면 로컬에서 개발할 때 번들링을 하지 않고 ESM 방식을 사용하기 때문에 로컬 서버 구동 속도가 매우 빠르다. 는 것이다. 그렇다면 여기서 번들링과 ESM 방식이 무엇인가.\n번들링 # 자바스크립트에서는 import, export를 사용해서 모듈 방식으로 개발을 한다. 따라서 모듈화 문법을 위한 장치가 필요하다. 모듈화를 위한 장치로 유명한 것으로 웹팩이 있다. 모듈화 문법을 사용해 단위로 묶는 것을 번들링이라고 한다. 아래 그림을 보면 이해가 쉽다. ESM # 자바스크립트 네이티브 모듈로 번들러 없이 브라우저 자체에서 실행가능한 모듈 방식이다.\n실행 시간 비교 # 모듈 번들러 중 웹팩을 예로 들어서 500개 정도의 모듈을 갖는 웹 서비스를 vite와 비교했을 때, 실행 시간은 vite가 20~30배 빠르다고 한다.\n이유는, 웹팩 데브 서버는 로컬 서버를 처음 시작할 때 관련 있는 모듈을 모두 번들링하여 메모리에 적재한다.\n그에 반해 비트는 시간을 소요하는 번들링 작업 없이 바로 서버를 실행하기 때문에 실행하기까지 많은 시간이 차이가 난다.\nStyled-component # Mixin css props # css props는 자주 쓰는 css 속성을 담는 변수이다. 전역 변수이기 때문에 컴포넌트 어디든 글로벌에서 정의한 mixin 기능을 사용할 수 있다. const {css 변수명} = css` {css 스타일 ...} ` 로 사용한다. Before\nexport const HeadingKrRegular4 = styled.span` font-family: \u0026#34;Hyundai Sans Head KR Regular\u0026#34;; font-size: 20px; line-height: 24px; letter-spacing: -0.003em; text-align: left; `; After\nexport const HeadingKrRegular4 = css` font-family: \u0026#34;Hyundai Sans Head KR Regular\u0026#34;; font-size: 20px; line-height: 24px; letter-spacing: -0.003em; text-align: left; `; span 태그로 생성하는 것이 아닌 css 속성을 변수화 하는것으로 변경했다. 이유는 span 태그로 사용할 경우 변경하고 싶으면 상속받은 후, 재사용에 불편함이 있기 때문이다.\n예시\n# 예시 import styled, {css} from \u0026#34;styled-components\u0026#34;; const flexCenter = css` display: flex; justify-content: center; align-items: center; `; const FlexBox = div` ${flexCenter} `; 검색해보니 위와 같이 자주 쓰는 css를 변수화해서 많이 사용한다고 한다. (새로운 지식 +1)\n","date":"1 August 2023","permalink":"/posts/cartag/%ED%94%84%EB%A1%9C%EC%A0%9D%ED%8A%B81/","section":"Posts","summary":"Cartag 프로젝트 #1 # 오늘부터 본격적으로 개발에 들어간다.","title":"[Project] Cartag 프로젝트 #1"},{"content":"","date":null,"permalink":"/tags/%EA%B0%9C%EB%B0%9C%EB%B0%A9%EB%B2%95%EB%A1%A0/","section":"Tags","summary":"","title":"개발방법론"},{"content":"현업에서 소프트웨어 개발 # 현업에서는 소프트웨어 개발을 진행할 때 프로젝트를 어떻게 만들지 설계를 해야한다. 이 때 쓰이는 것은 개발 방법론, 깃 브랜치 전략 등이 있다. 오늘을 팀과 그라운드 룰, 여러 협업 전략에 대해 이야기를 나누고 규칙을 세워봤다. 그 과정에서 소프트웨어 개발 방법론을 전체 강의에서 들으면서 다시금 소프트웨어 개발 실무 수업을 듣던 예전으로 돌아간 것 같았다.. 이 개념들은 질문에서도 가끔 등장하기 때문에 오랜만에 정리하는 시간을 가져본다.\n소프트웨어 개발 방법론 # 크게 Waterfall 방법론, Agile 방법론이 있다. 이 중 Agile 방법론이 유연한 대처가 가능해서 많이 쓰인다. Agile 방법론 중에서는 주로 Scrum, Kanban이 많이 쓰인다.\nAgile Scrum # 일주일~이주일 스프린트에 적합한 프로젝트에 유용하다. 일반적으로 Scrum 팀은 규모가 작다. 역할은 다음과 같이 나뉜다.\n1. 제품 소유주 : 프로젝트의 핵심 이해 당사자로 프로젝트 비전 정의 : 백로그 관리, 종속성 배치, 니즈 우선순위화, 클라이언트 니즈 예측 : 클라이언트와 팀 연락 담당 2. 스크럼 마스터/프로젝트 매니저 : 팀에 작업을 지시해 회의 구성 : 진행률 감시 및 작업 완료 방해 요인 제거의 책임 3. 팀 : 공식적인 리더가 없음. 팀은 전문 지식과 자원을 사용해 목표를 달성 장점\n모든 사람이 책임을 공유 신속한 개발 단점\n기술과 경험을 갖춘 혁신적인 팀 필요 빡빡한 타임라인 매일 회의 일정 잡는 것이 어려움 다양한 프로젝트에 참여하는 팀 구성원의 우선순위 변화로 인해 결과물 지연 가능성 Sprint BurnDown # 스프린트 작업에 할당된 남은 작업을 기반으로 번다운 추적을 지원한다.(jira 같은 협업툴에서 지원) 따라서 번다운 차트를 보면서 본인의 작업 속도를 객관적으로 파악 가능하다.\nAgile Kanban # Agile Scrum은 짧은 타임라인에 초점을 맞추지만 Agile Kanban 방법론에는 고정 길이 스프린트가 없다. → 작업이 지속되고 제품 제공도 지속된다는 의미이다.\n작업에 대한 타임라인을 표시하지 않고 항목과 결과물이 완성된 시점을 보여준다. 설정된 역할이 없고 팀 전체가 보드를 소유한다.\n장점\n진행중인 작업 양을 제한해서 중요한 작업에 초점을 맞추는데 도움 수용 작업량이 빌 때마다 새로운 항목 추가 가능 매일 회의 불필요 지속적인 개선 가능 워크플로우 시각화 단점\n타임라인이 없어 느슨한 작업이 될 수 있음 책임자가 없음 ","date":"31 July 2023","permalink":"/posts/software-engineering/software-engineering/","section":"Posts","summary":"현업에서 소프트웨어 개발 # 현업에서는 소프트웨어 개발을 진행할 때 프로젝트를 어떻게 만들지 설계를 해야한다.","title":"소프트웨어 개발 방법론"},{"content":"","date":null,"permalink":"/tags/%EC%86%8C%ED%94%84%ED%8A%B8%EC%9B%A8%EC%96%B4%EA%B3%B5%ED%95%99/","section":"Tags","summary":"","title":"소프트웨어공학"},{"content":"","date":null,"permalink":"/categories/%EC%86%8C%ED%94%84%ED%8A%B8%EC%9B%A8%EC%96%B4%EA%B3%B5%ED%95%99/","section":"Categories","summary":"","title":"소프트웨어공학"},{"content":"Type script 공부 #4 # 노마드코더 강의 링크 오늘도 이어서 하는 타입스크립트 클론 코딩! 🐜\n👇🏻 아래는 클론코딩용 깃허브 레포지토리 링크이다. 👇🏻\n깃허브 링크\n오늘 완료한 기능 구현은 다음과 같다.\ncoin 상세 화면 구현 coin 상세 화면 내 탭 구현 API interface # [TS] Type script 공부 #3 여기서 API 인터페이스를 작성할 때 중요한 점이 있다. 가장 중요한 단점이 있기 때문이다. Object.values(temp1).map(v =\u0026gt; typeof v).join()으로 타입을 얻을 경우에는, array가 있으면 object로 결과가 나오기 때문에 직접 설명해줘야 한다. 따라서 타입이 object로 나오는 key들은 아래와 같이 상세 보기를 눌러줘서 복사+붙여넣기를 해서 수정해준다. interface ITag { coin_counter: number; ico_counter: number; id: string; name: string; }\n수정을 하면 다음과 같다.\n# Coin.tsx // 각 object를 설명해주는 인터페이스 추가 interface ITag { coin_counter: number; ico_counter: number; id: string; name: string; } interface InfoData { // object를 해당하는 인터페이스로 수정 tags: ITag[]; } // 설명 완료된 api 인터페이스를 적용 const [info, setInfo] = useState\u0026lt;InfoData\u0026gt;(); const [priceInfo, setPriceInfo] = useState\u0026lt;PriceData\u0026gt;(); 예외 # 이전 포스팅에서 아래와 같이 말했다.\n하지만, 아래의 상황에서 문제가 발생할 가능성이 있다. 1. 시크릿창일 때 링크의 데이터를 못 받는다. 2. 링크로 다이렉트로 검색할 때 위의 예외 처리를 해주어야 한다. 이 경우에는,\n\u0026lt;Title\u0026gt; 코인 {state?.name ? state.name : loading ? \u0026#34;Loading...\u0026#34; : info?.name} \u0026lt;/Title\u0026gt; state가 없으면(이전 링크에서 데이터를 받지 않았다는 의미) 로딩 상태 확인 로딩 끝나면 info.name을 띄어준다. 예외처리를 이렇게 해준다.\nuseEffect # 리액트에는 여러가지 사용할 수 있는 Hook들이 있다. useEffect는 그 중 한가지이다. 컴포넌트가 렌더링 될 때 특정 작업을 실행할 수 있도록 하는 Hook이다\nuseEffect(() =\u0026gt; { // 실행 함수 }, []); 첫번째 인자(effect)는 함수, 두번째 인자는 배열(deps)이다.\ndeps # 빈 배열을 입력할 경우 컴포넌트가 렌더링 될 때에만 실행된다. 즉, []은 no dependency를 의미한다. 특정한 값이 변경될 때 effect 함수를 실행하고 싶을 경우 배열 안에 그 값을 넣어준다. 만약, [x] 넣었을 경우 x의 상태가 변화면 다시 실행된다. 이 때, 리액트는 Hook 안에서 사용하는 변수는 dependency 넣는 것을 권장한다.\nuseRouteMatch # 또 다른 Hook이다. useRouteMatch는 현재 위치를 기준으로 지정된 경로에 대한 일치 데이터를 반환한다. 즉, 현재 특정한 url에 있는지 여부를 알려준다.\n(v6에서는 useMatch로 써야한다. ++ 참고로 Switch -\u0026gt; Routes)\nmatchPath() # url 경로 이름에 대해 경로 패턴을 일치시키고 일치에 대한 정보를 반환한다.\nnested router # route 안에있는 또 다른 라우트 렌더링 가능하게 해준다.\n웹사이트에서 탭을 사용할 때 스크린 안에 많은 섹션이 나눠진 곳 을 구현할 때 아주 유용하다. 탭 구현 # 위에서 설명한 useRouteMatch와 nested router를 사용해서 탭을 구현할 수 있다. url..말고도 state로도 할 수 있지만 url이 사용성이 높다. 사용자가 바로 접속할 수 있기 때문이다.\n# Coin.tsx // Tab의 스타일 컴포넌트 const Tab = styled.span\u0026lt;{ isActive: boolean }\u0026gt;` text-align: center; text-transform: uppercase; font-size: 12px; font-weight: 400; background-color: rgba(0, 0, 0, 0.5); padding: 7px 0px; border-radius: 10px; color: ${(props) =\u0026gt; props.isActive ? props.theme.accentColor : props.theme.textColor} a { display: block; } `; // 스타일 컴포넌트에게 isActive 값을 넘겨준다. \u0026lt;Tab isActive={chartMatch !== null}\u0026gt; \u0026lt;Link to={`/${coinId}/chart`}\u0026gt;Chart\u0026lt;/Link\u0026gt; \u0026lt;/Tab\u0026gt; \u0026lt;Tab isActive={priceMatch !== null}\u0026gt; \u0026lt;Link to={`/${coinId}/price`}\u0026gt;Price\u0026lt;/ Link\u0026gt; \u0026lt;/Tab\u0026gt; const priceMatch = useRouteMatch(\u0026#34;/:coinId/price\u0026#34;); const chartMatch = useRouteMatch(\u0026#34;./coinId/chart\u0026#34;); 구현 화면 # 탭을 누르면 누른 탭이 활성화된다. ","date":"30 July 2023","permalink":"/posts/type-script/type-script4/","section":"Posts","summary":"Type script 공부 #4 # 노마드코더 강의 링크 오늘도 이어서 하는 타입스크립트 클론 코딩!","title":"[TS] Type script 공부 #4"},{"content":"","date":null,"permalink":"/tags/%EB%85%B8%EB%A7%88%EB%93%9C%EC%BD%94%EB%8D%94/","section":"Tags","summary":"","title":"노마드코더"},{"content":"","date":null,"permalink":"/categories/%ED%83%80%EC%9E%85%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8/","section":"Categories","summary":"","title":"타입스크립트"},{"content":"Type script 공부 #3 # 노마드코더 강의 링크 오늘도 이어서 타입스크립트 공부를 시작했다. 어제까지 타입스크립트 개념 강의는 모두 끝내고 오늘부터는 3가지 클론 코딩 프로젝트 중 암호화폐 시세 트래커를 시작한다.\n👇🏻 아래는 클론코딩용 깃허브 레포지토리 링크이다. 👇🏻\n깃허브 링크\n전역 style # reset.css # 브라우저의 기본 스타일들을 초기화해주는 css 파일로 기본값을 제거해주는 역할을 한다. 보통 1. 인터넷에 검색하면 나온 것을 복사+붙여넣기 해서 reset.css 파일을 만들거나 2. npm i styled-reset 명령어로 설치할 수 있다.\ncreateGlobalStyle # 전역 스타일을 처리하는 특수 Styled Component를 생성하는 helper 함수이다. 한 컴포넌트를 만들 수 있게 해주는데 렌더링될 때 이 컴포넌트는 전역 스코프에 스타일들을 알려준다.\n이 때 우리는 두 개의 element를 써야하는데 \u0026lt;GlobalStyle/\u0026gt;\u0026lt;Router/\u0026gt; 리액트는 하나만 리턴해야 한다. if, \u0026lt;div\u0026gt;로 감싸면 어플리케이션은 쓸모없는 div가 많아지므로 bad practice이다.\nfragment # 일종의 유령 컴포넌트이다. 부모없이 서로 붙어있는 많은 엘리먼트들을 리턴할 수 있게 해준다.\nAPI의 인터페이스 # 타입스크립트에서는 API도 인터페이스를 설정해줘야 한다. ㅎㅎ 물론, API의 type에 대한 정보를 자동생성하는 좋은 사이트도 존재하지만(이건 후술하겠다.)이번 강의에서는 직접 만들기 때문에 해보겠다.\ntype 정보 생성 # 우선 console.log로 얻은 데이터를 콘솔에 출력한다. 그리고 콘솔창에서 우클릭을 하면 전역 변수로 Object 저장을 눌러준다. 1번 과정을 끝내면 위와 같이 temp로 저장된다. 저장한 객체를 keys.join()하면 string으로 나온다. 위의 문자열을 복사해서 붙여놓고 Object.values(temp1).map(v =\u0026gt; typeof v).join()로 타입 또한 결과를 얻어서 붙여넣으면 완성! issue # react-router-dom v5 버전 사용 시 URL 은 변하는데 렌더링이 안되는 이슈가 있다. 나 또한 강의를 따라하느라 같은 이슈가 발생했다. (강의에서는 버전 5 사용, 최신은 버전 6이기 때문에 차이가 있다.)\n1. index..tsx 에서 렌더 내부의 React.StrictMode 를 div 로 변경 2. react-router-dom v6을 사용\n나는 1을 사용해서 해결했다.\n각종 소소한 정보 \u0026amp; Tips # 정보 # coininterface[]는 CoinInterfaces의 배열을 의미한다. tip\n(함수)(); 이렇게 작성하면 바로 실행된다. -\u0026gt; 즉시 실행 함수 참고\n비하인드 더 씬\nLink를 통해 state를 보낼 수 있다. to에 경로만 적지 말고 {} 객체로 감싸서 보내면 데이터까지 전송할 수 있다.\n\u0026lt;Link to={{ pathname: `/${coin.id}`, state: { name: coin.name }, }} 데이터를 받는 컴포넌트에서는 아래와 같이 useLocation을 사용해서 사용하면 된다.\ninterface RouteState { name: string; } const { state: { name }, } = useLocation\u0026lt;RouteState\u0026gt;(); \u0026gt; 하지만, 아래의 상황에서 문제가 발생할 가능성이 있다.\n→ 시크릿창일 때 링크의 데이터를 못 받는다. → 링크로 다이렉트로 검색할 때 위의 예외 처리를 해주어야 한다.\n캡슐화 const response = await( await fetch(`https://api.coinpaprika.com/v1/coins/${coinId}`) ).json(); 타스 코드베이스를 보면 가끔 interface를 적을 때 I를 맨앞에붙이고 하는 경우 왕왕 있다.\n특수 문자 코드표\n\u0026amp;rarr; 이렇게 작성하면 오른쪽 화살표를 의미한다. 참고\nTip 🍯 # # VSCode 단축키 Ctrl(Command)+D: 같은 문자열 선택 Shift+Alt(Option)+i: 선택한 모든 문자열에 가장 우측 끝으로 포커싱 Ctrl(Command)+Shift+오른쪽 화살표: 현재 선택한 문자열을 기준으로 우측 끝까지 문자열 선택 노마드코더 코딩 인생 꿀템 VSC 단축키 5분 정리 JSON데이터를 타입스크립트 타입으로 빠르게 변환시켜주는 사이트 ","date":"29 July 2023","permalink":"/posts/type-script/type-script3/","section":"Posts","summary":"Type script 공부 #3 # 노마드코더 강의 링크 오늘도 이어서 타입스크립트 공부를 시작했다.","title":"[TS] Type script 공부 #3"},{"content":"Type script 공부 #2 # 노마드코더 강의 링크 사실 오늘은 개발 시간이 없고 기획+디자인 리뷰와 데모 영상 시연으로 공부를 거의 하지 못했다. 따라서 어제 정리한 내용이지만 분량 상 적지 않았던 것을 적어보고자 한다.\ninterface # interface는 object 설명해주는 것이라고 보면 된다. 인터페이스는 변수의 타입으로 사용할 수 있다. 이때 인터페이스를 타입으로 선언한 변수는 해당 인터페이스를 준수하여야 한다. 만약 required가 아닌 변수는 다음과 같이 ?를 뒤에 붙여 optional props로 선언해주면 된다.\ninterface Exxample { required: string; optional?: string; // props가 선택적으로 입력되는 경우 } 인터페이스 관련 좋은 예시 # PropTypes(리액트 라이브러리)와 비슷하지만 interface는 코드가 실행되기 전 확인해준다.\n# Player.js interface PlayerShape { name: string; age: string; } const sayHello = (playerObj: PlayerShape) =\u0026gt; `Hello ${playerObj.name}. You are ${playerObj.age} years old.`; sayHello({name:\u0026#34;nico\u0026#34;, age:12}) 위에서 이전에 정리한 화살표 함수 표현식이 사용되었다..! 참고:[현대 소프티어] FE 뉴스스탠드 #2 여기서 [번외] 화살표 함수로 이동해서 보면 된다.\ninterface를 통한 다크모드 구현 # # styled.d.ts import \u0026#34;styled-components\u0026#34;; declare module \u0026#34;styled-components\u0026#34; { export interface DefaultTheme { textColor: string; bgColor: string; btnColor: string; } } d.ts는 declaration file 이라는 뜻이다. d.ts로 된 확장자를 통해 styled-components에 DefaultTheme 인터페이스를 확장해준다. 이제 애플리케이션에서 사용하는 테마의 형태를 정의할 수 있다. 예를 들어, 이 코드에서는 DefaultTheme에 textColor, bgColor, 그리고 btnColor라는 세 가지 속성이 추가되어 테마의 색상을 관리할 수 있도록 한다.\n# theme.ts import { DefaultTheme } from \u0026#34;styled-components\u0026#34;; export const theme: DefaultTheme = { bgColor: \u0026#34;white\u0026#34;, textColor: \u0026#34;black\u0026#34;, btnColor: \u0026#34;tomato\u0026#34;, }; theme.ts에서 테마를 해당 인터페이스 props에 대응하는 테마를 만들고 index.tsx에서 다음과 같이 작성해주면 된다.\n\u0026lt;ThemeProvider theme={theme}\u0026gt; \u0026lt;App /\u0026gt; \u0026lt;/ThemeProvider\u0026gt; 이렇게 App에게 전해주고 App에서 해당 테마를 사용하면 완료! 매우 간편하다. 이제 타입스크립트 개념 강의는 끝나서 실제 프로젝트를 클론 코딩한다. 두근두근\n","date":"28 July 2023","permalink":"/posts/type-script/type-script2/","section":"Posts","summary":"Type script 공부 #2 # 노마드코더 강의 링크 사실 오늘은 개발 시간이 없고 기획+디자인 리뷰와 데모 영상 시연으로 공부를 거의 하지 못했다.","title":"[TS] Type script 공부 #2"},{"content":"Type script 공부 #1 # 노마드코더 강의 링크 오늘은 어제 뉴스스탠드 기능 구현을 완료했으므로 예외 처리 간단한 거 3개만 해주고 8월에 있는 프로젝트를 위해 노마드코더의 타입스크립트 강의를 봤다. 강의를 보고 클론 코딩하면서 메모하고 싶은 개념들을 아래에 정리하겠다.\nstring interpolation # 하하 이거는 전에도 interpolation이 무슨 뜻일까? 궁금해서 검색해봤는데 정리를 안하니까 까먹은 개념이다. 정확히 말하면 알던 개념이지만 이것을 string interpolation이라고 하는지 몰랐다. 이제는 기억하기 위해 적어놓는다.\n# string interpolation ${변수명} 문자열 인터폴레이션 은 해당 값으로 대치된 결과를 생성하는 과정이다. 위의 코드에서는 해당 변수명의 값으로 대체된다. (비슷하게 변수 인터폴레이션, 변수 대체, 변수 확장라고도 한다.) js에서 굉장히 많이 쓴다..!\n타입스크립트 # 대망의 타입스크립트..! 말로만 듣고 처음 본다. 타입스크립트는 자바스크립트를 기반으로 한 프로그래밍 언어로 자바스크립트와는 다른 언어이다. 하지만 기반으로 했기 때문에 몇 가지 차이점을 제외하고는 비슷하다. 타입스크립트의 두드러지는 특징으로는 다음과 같다.\nstrongly-typed 언어 # 이름에서부터 알다싶이 타입스크립트는 코드를 작성할 때 타입을 명시해야한다. 그러면 타입스크립트는 프로그래밍 언어가 작동하기 전에 type을 확인한다. 작동 원리 브라우저는 js밖에 이해하지 못하므로 ts는 컴파일하면 js로 바뀐다. 따라서 protection은 코드 작동 전 발생한다. 코드 작성 전에 타입이 맞는지 보고 문제가 없으면 js 코드를 리턴한 것을 브라우저가 띄어준다.\n번외 # js에서 쓰는 라이브러리들은 타입들을 ts가 알 수 있게 해줘야한다. 이때, @types를 사용해서 ts에게 타입을 알려줄 수 있다. 거대한 github repository 유명한 npm 라이브러리를 가지고 있는 저장소로 여기서 라이브러리나 패키지의 type definition 을 알려준다.\n타입스크립트 장점 # props 오타 등의 실수를 알 수 있다. 타입 틀렸을 때 컴파일 전에 알 수 있다. ?? Null 병합 연산자 (Nullish coalescing operator) # ?? 앞에 값이 null이거나 undefined이면 오른쪽 값을, 그렇지 않으면 왼쪽 값을 반환하는 논리연산자\n# 예시 null ?? \u0026#34;hello\u0026#34; // \u0026#34;hello\u0026#34; undefined ?? \u0026#34;hello\u0026#34; // \u0026#34;hello\u0026#34; \u0026#34;hi\u0026#34; ?? \u0026#34;hello\u0026#34; // “hi\u0026#34; currentTarget과 target 차이 # https://choonse.com/2022/01/14/605/ typescript에서 reactjs는 currentTarget 사용을 택했다. ES6 문법 # https://nomadcoders.co/react-masterclass/lectures/3336 -몰랐던 신기한 es6 문법\nconst { currentTarget: { value }, } = event; event안 curentTarget안에 value의 값을 기존 이름 그대로 value 라는 변수를 만든다. const value = event.currentTarget.value 랑 같은 의미이다. 왜 사용할까? currentTarget안에서 value, tagName, width, id 등 여러 개 를 가져오고 싶을 때 장점이 있다.\n# 기존 문법 const value = event.currentTarget.value; const tagName = event.currentTarget.tagName; const width = event.currentTarget.width; const id = event.currentTarget.id; 이거를 이렇게 바꿔 쓸 수 있다.\n# ES6 문법 const { currentTarget: {value, tagName, width, id} } = event; ","date":"27 July 2023","permalink":"/posts/type-script/type-script1/","section":"Posts","summary":"Type script 공부 #1 # 노마드코더 강의 링크 오늘은 어제 뉴스스탠드 기능 구현을 완료했으므로 예외 처리 간단한 거 3개만 해주고 8월에 있는 프로젝트를 위해 노마드코더의 타입스크립트 강의를 봤다.","title":"[TS] Type script 공부 #1"},{"content":"FE 뉴스스탠드 4주차 # 참고 fe-newsstand #4 fe-newsstand 7.26 버그 수정 fe-newsstand 7.26 리스트뷰 랜덤 구현 fe-newsstand 7.26 예외 처리\n구현한 기능 # 기능 구현\n리스트뷰 랜덤순서 구독한 언론사 탭 누르면 리스트뷰 디폴트 설정 예외 처리 및 버그 수정\n25개일때 해지하고 페이지 처리 여러 개 해지되는 현상 해결 오버플로우 뒤에 위치한 언론사 위치 조정 첫번째 페이지에서 이전 버튼 클릭시 마지막 페이지 그리드뷰 버튼에만 클릭이벤트 범위 적용하기 구독한 언론사 아무것도 없을때 -\u0026gt; alert 처리 25개일때 해지하기 페이지 처리 여러개 해지되는 현상 해결 To do list # 다른 곳 선택 시 스낵바 에니메이션 제거 리팩토링 시연 영상 # 에휴 항상 시연 영상 찍다가 버그를 발견한다. 전에 고친 버그인데 잘못 수정하다가 다시 발생한 것 같다. To do. 다른 곳 선택하면 스낵바 애니메이션 종료 후 구독한 언론사 탭으로 이동하는 이벤트 제거\n어려웠던 점 # 오늘은 어제 고치기로 생각한 해지가 여러번 되는 현상을 수정하느라 애먹었다. (7/26) 참고 해지 여러번 되는 버그 해결\nBefore # # subscribePress.js export function handleSubscribe(_press) { const isSubscribed = getSubscribedPress().some( (press) =\u0026gt; press.name === _press.name ); document.addEventListener(\u0026#34;click\u0026#34;, (e) =\u0026gt; checkRange(e)); deletePopupAndAnimation(); closeAllPopups(); //구독한 상태에서 누를 경우 if (isSubscribed) { store.setState({ currentPress: _press }); const alert = document.querySelector(\u0026#34;.alert\u0026#34;); alert.style.display = \u0026#34;block\u0026#34;; const press_msg = alert.querySelector(\u0026#34;.press\u0026#34;); press_msg.innerHTML = `${getCurrentPress().name}`; const btn = document.querySelector(\u0026#34;.buttons\u0026#34;); btn.addEventListener(\u0026#34;click\u0026#34;, (e) =\u0026gt; { checkAnswer(e, _press); alert.style.display = \u0026#34;none\u0026#34;; }); } //구독하지 않았을 때 =\u0026gt; 구독됨 else { const updatedSubscribedPress = [...getSubscribedPress(), _press]; store.setState({ subscribedPress: updatedSubscribedPress }); const snackbar = document.querySelector(\u0026#34;.snackbar\u0026#34;); snackbar.style.display = \u0026#34;block\u0026#34;; document.addEventListener(\u0026#34;animationend\u0026#34;, (e) =\u0026gt; handleAnimationEnd(e, _press) ); //구독한 상태로 바뀜 getView() === \u0026#34;grid\u0026#34; ? showGridView() : showListView(); }} 원래 버그 해결 전에는 각각 showGridView와 showListView에서 구독 또는 해지 버튼을 클릭할 경우에 subscribe.js 파일에서 handleSubscribe 함수를 불러와서 실행하였다. 이렇게 실행된 handleSubscribe는 각각 구독인지/해지인지 판단하고 해당하는 이벤트를 등록해주었다. 이렇게하니 해지하기 버튼을 선택하지 않고 곧바로 다른 언론사의 해지하기 버튼을 누르면 이벤트가 중첩돼서 삭제가 중첩되었다. 따라서 다음 코드와 같이 대대적으로 함수를 이동시켰다.\nAfter # # MainView.js function attachEventListner() { document.addEventListener(\u0026#34;click\u0026#34;, (e) =\u0026gt; handleClick(e)); document.addEventListener(\u0026#34;animationend\u0026#34;, (e) =\u0026gt; handleAnimationEnd(e)); const btn = document.querySelector(\u0026#34;.buttons\u0026#34;); btn.addEventListener(\u0026#34;click\u0026#34;, (e) =\u0026gt; { checkAnswer(e); });} 위의 코드는 버그를 고친 후이다. 이벤트 등록을 view 최상위인 MainView.js에서 등록을 해주었다. 이렇게 하니 애니메이션 중첩 현상이 사라졌다!\n코드리뷰 # 오늘은 수요일이기 때문에 크롱님께서 다른 분들의 코드를 보며 리뷰해주시는 시간을 가졌다.\n비동기 함수 병렬 처리 비동기 함수에는 await, promise 등이 있다. 비동기 함수를 쓰다보면 api 여러개 써야할 때가 있다. 이럴 때에는 await을 여러 번 사용하는 경우 순차적으로 실행이 다 된 후에 코드들이 진행되기 때문에 일종의 blocking 현상이 발생한다. 이럴 때에는 promise.all를 통해 해결할 수 있다. promise.all을 사용하고 이후 .then을 통해 병렬 처리 해주면 된다. 그러면 비동기 함수들을 병렬 처리할 수 있다. Delegation 크롱님께서 저번 시간과 이번 시간에 Delegation에 대해 말씀해주셔서 뭔지 궁금해서 검색해보았다. 간단히 말하면 디자인 패턴의 일부로 어떤 helper 객체를 이용하여 데이터를 제공하거나 특정 작업을 수행하는 것을 위임하는 패턴을 말한다. 마치며 # 이번주까지 완성해야 했던 뉴스스탠드의 기능 완료를 끝내서 너무 뿌듯하다. 언제 완성하지 막막했던 것이 엊그제같은데 ㅠㅠ 이제 남은 것은 시연하면서 알게 된 재발생한 버그+리팩토링이다. 하 리팩토링 어디서부터 건들여야 할 지\u0026hellip; 오늘은 짜투리 시간에 Styled Component도 공부해봤다. 잠깐 맛만 봤는데 신세계다.\n","date":"26 July 2023","permalink":"/posts/fe-newsstand/fe-newsstand9/","section":"Posts","summary":"FE 뉴스스탠드 4주차 # 참고 fe-newsstand #4 fe-newsstand 7.","title":"[현대 소프티어] FE 뉴스스탠드 #9"},{"content":"","date":null,"permalink":"/tags/newsstand/","section":"Tags","summary":"","title":"newsstand"},{"content":"","date":null,"permalink":"/tags/%ED%98%84%EB%8C%80%EC%86%8C%ED%94%84%ED%8B%B0%EC%96%B4/","section":"Tags","summary":"","title":"현대소프티어"},{"content":"FE 뉴스스탠드 4주차 # 참고 fe-newsstand #4 fe-newsstand 7.25 구독하기 기능 관련 상세 사항 구현 구현한 기능 (7/25) # 글자수 많은 언론사 alert 버그 문제 해결 이미지 호버시 확대 5% =\u0026gt; 리스트뷰 구독한 언론사에도 적용 선택한 카테고리 외 마우스 호버 시 밑줄 타이포그래피 스타일 파일 분리 및 적용 구독한 언론사 탭 카테고리 스크롤도 가능하도록 구현 팝업창 한 번 만들고 display로 컨트롤 [리팩토링] 함수 모듈화 =\u0026gt; drawCategory, mainview 학습 내용 # prototype # \u0026quot;abc\u0026quot;.charAt === \u0026quot;dfg\u0026quot;.charAt을 하면 결과값은 true로 나온다. prototype에 있기 때문에 메소드는 동일한 메소드를 가리킨다. 더 자세히 알아보자.\n자바 스크립트는 모든 것이 객체다.\n라는 말이 있다. 아래의 예시를 보면\nclass Foo { constructor(name) { this.name = name; } getName() { return this.name; } } 을 하고 마찬가지로 new Foo(\u0026quot;crong\u0026quot;).getName === new Foo(\u0026quot;newcrong\u0026quot;).getName을 하면 true가 결과로 나온다. 하지만\nclass Foo { constructor(name) { this.name = name; this.getName = () =\u0026gt; { return this.name; }; } } 위와 같이 constructor 안에 getName 메소드를 넣으면 결과는 false이다. 이유는 바로 자바 스크립트의 prototype과 관련이 있다. js에는 상속의 개념이 없다. 비슷한 개념으로 native api(prototype)이 있다. 이는 객체가 생성되면 상위 메소드를 share하는 개념이다. 최상위 object까지 prototype chain 연결을 통해 toString까지 최후에는 다다른다. extends를 통해 사이에 새로운 prototype을 만들 수도 있다. cf) 문자열은 객체가 아닌 primitive type이지만 \u0026quot;string\u0026quot;.method이렇게 .을 붙이는 순간 객체가 된다. Wrapper Object\n이벤트 위임 # 이벤트 위임은 이벤트 버블링(전파)을 방지해준다.\nevent.target은 밖을 눌러도 leaf node를 가리키기 때문에 이벤트 위임이 가능하다. 위임으로 구현하면 메모리의 이벤트 핸들러 갯수를 감소해서 메모리 효율성을 증가할 수 있다. stopPropagation()이라고 이벤트 위임 외에도 이벤트 버블링을 방지하는 메소드도 존재한다.\n[번외] 리액트는 이벤트위임을 직접해준다. (onClick 이벤트를 등록하면 이벤트 리스너들은 document로 올라가서 모이고. 클릭이벤트가 실행되면 분기별로 등록한 이벤트를 처리해준다.)\nstate 관리 # 싱글페이징 구조는 클라이언트가 상태를 가지면 안 되기 때문에 상태 관리 별도로 필요\nFlux 아키텍쳐 MVC도 가능(옵저버패턴) Mediator 패턴(state를 둬서 전달자처럼 상태가 바뀐 것을 알려준다.) 그 외 여러가지가 존재한다.\nstore는 관련있는 애들끼리 모아놓기! 아니면 관련 없는 함수가 쓸데없이 실행된다. react는 diff 알고리즘이 있어서 렌더링 변경시 이전 상태와 현재 상태를 비교해서 달라질 경우에만 DOM 부분을 렌더링한다. 마치며 # 이제 리스트뷰 새로고침 시 랜덤 구현과 드래그 할 때 뒷부분이 가려지는 문제를 해결하면 얼추 기능 완성에 가까워진 것 같다. 마지막에 버그를 발견했는데 못 고치고 집을 가서 슬프다.. 내일 아침에 바로 해야겠다. To do. 25개 이상일 때 삭제하면 가끔 여러개 삭제됨. ","date":"25 July 2023","permalink":"/posts/fe-newsstand/fe-newsstand8/","section":"Posts","summary":"FE 뉴스스탠드 4주차 # 참고 fe-newsstand #4 fe-newsstand 7.","title":"[현대 소프티어] FE 뉴스스탠드 #8"},{"content":"FE 뉴스스탠드 4주차 # 참고 fe-newsstand #4 fe-newsstand 7.24 그리드뷰 구독 클릭 이벤트 fe-newsstand 7.24 다크모드 구현 fe-newsstand 7.24 구독한 언론사 드래그 기능 구현\n구현한 기능 # 리스트 뷰 메인 로고 썸네일에 마우스 호버 시 5% 확대 다크모드 (추가 미션) 카테고리 추가영역 노출 처리(선택) 리스트뷰 뉴스 제목 호버 시 밑줄 표시 To do list # 언론사 글자 수가 길 때 다음 줄로 넘어가는 문제 (알럿) 리스트뷰 랜덤 순서 구현 오버플로우 뒤에 위치한 언론사 위치 조정 리팩토링 시연 영상 # 시연 영상 찍다가 버그 발견했다. 구독한 언론사 탭 부분 이미지는 확대가 호버 시 안 되는 것 같다.\n어려웠던 점 # 오늘은 이벤트를 주로 다뤄서 이벤트 관련 부분에서 어려움을 많이 겪었다. (7/24)\n1. 스낵바 애니메이션 종료 후, 2번 실행되는 문제 # css 애니메이션이 fade-in, fade-out 2번 적용되기 때문에 2번 실행되는 것이었다. 디버깅 때 찾느라 시간이 많이 걸렸다. 찾고나서는 간단하게 animationEnd이벤트 리스너로 event.animationName이 fade-out일 때에만 구독한 언론사로 넘어가게 구현했다. 2. 해지하기 이벤트 리스너가 한번만 실행됨 # 개발자 도구를 이용해서 html 소스를 뜯어보니 보면 이전 popup(snackbar, alert)이 계속 겹쳐진 것이었다. 따라서 클릭을 해도 이벤트가 등록되지 않은 버튼이 눌려서 버튼 클릭 이벤트가 실행되지 않았다. 일단 document.querySelector(\u0026quot;popup\u0026quot;)을 통해 있다면 removeChild를 통해 제거했으나 같은 팀원분께서 display.none을 통한 것이 cost가 절감될 것이라고 해서 리팩토링 때 할 예정이다. 3. mouse up, click 구분 # 오늘 구현한 기능 중 구독한 언론사가 많으면 드래그를 통해 스크롤 할 수 있게 하는 기능이 있다. 여기서 드래그가 끝날 때의 up을 할 때 click 이벤트도 같이 실행되었다. tabContainer.addEventListener(\u0026#34;mousedown\u0026#34;, (e) =\u0026gt; { isDragging = true; startScrollX = e.pageX + tabContainer.scrollLeft; tabContent.style.cursor = \u0026#34;grabbing\u0026#34;; startClickX = e.pageX; }); window.addEventListener(\u0026#34;mousemove\u0026#34;, (e) =\u0026gt; { if (!isDragging) return; e.preventDefault(); const scrollX = startScrollX - e.pageX; tabContainer.scrollLeft = scrollX; }); window.addEventListener(\u0026#34;mouseup\u0026#34;, (e) =\u0026gt; { isDragging = false; tabContent.style.cursor = \u0026#34;grab\u0026#34;; if (startClickX === e.pageX) { handleClick(e); } }); startClickX는 드래그 시작 시의 X 좌표 값을 기억하는 변수로, 나중에 클릭 이벤트와 드래그 이벤트를 구분하는데 사용된다. if (startClickX === e.pageX) { ... }는 드래그와 클릭 이벤트를 구분하기 위해 드래그 이벤트가 발생하기 전과 마우스를 누르고 뗀 지점의 X 좌표를 비교한다. 만약 드래그 없이 마우스를 클릭했다 떼었다면, handleClick(e) 함수를 호출한다.\n++ 드래그 이벤트도 따로 빼면 좋을 것 같다.\n","date":"24 July 2023","permalink":"/posts/fe-newsstand/fe-newsstand7/","section":"Posts","summary":"FE 뉴스스탠드 4주차 # 참고 fe-newsstand #4 fe-newsstand 7.","title":"[현대 소프티어] FE 뉴스스탠드 #7"},{"content":"FE 뉴스스탠드 (주말에도 이어서 \u0026hellip;) # 참고 fe-newsstand\nDone # 오늘은 주말이지만 열심히 코딩을 달렸다. 왜냐? 곧 8월에 프로젝트를 들어가기 전에 미션은 빨리 끝내면 좋을 것 같아서\u0026hellip; 지금 블로그 글을 쓰고 있는 와중에 너무 졸리다. 구현한 기능은 아래와 같이 할 일 목록들 중 5개 정도 구현했다.\n오늘 구현하면서 DOM에 대해 더 알게 된 것 같다.\nDOM # 우선 DOM에 대해 무엇인지 간단하게 짚고 가겠다.\nDocument Object Model # HTML 문서에 접근하기 위한 일종의 인터페이스이다. DOM은 계층적으로 정보를 표현하는 노드 트리 구조이다. 위의 그림과 같이 우리가 흔히 알고있는 div, span 등은 노드이다. 여기서 text 정보 또한 노드인 것을 유념해야 한다. html 정보들을 바꾸고 싶을 때 우리는 DOM API를 많이 사용하는데 다음과 같은 것들이 있다.\nDOM API # # 노드 선택 querySelector(), querySelectorAll() getElementById() # 노드 탐색 parentNode(), firstChild() # 노드 생성 및 삭제 createElement() appendChild() removeChild() # 노드 정보 변경 innerHTML, innerText; DOM API는 매우 편리하지만 변경함에 따라 이벤트가 작동이 안 될수도 있다는 것을 알아야 한다\u0026hellip;\n코드에서 DOM API # # 실행 함수 function handleEvent(event, img) { const li = img.parentNode; const button = img.nextElementSibling; switch (event) { case \u0026#34;over\u0026#34;: img.style.display = \u0026#34;none\u0026#34;; button.style.display = \u0026#34;flex\u0026#34;; li.style.backgroundColor = \u0026#34;var(--surface-alt)\u0026#34;; break; case \u0026#34;out\u0026#34;: img.style.display = \u0026#34;block\u0026#34;; button.style.display = \u0026#34;none\u0026#34;; li.style.backgroundColor = \u0026#34;var(--surface-default)\u0026#34;; break; default: break; } } # 이벤트 핸들러 export function showGridView() { (생략) for ( let i = PRESS_VIEW_COUNT * (getPage() - 1); i \u0026lt; PRESS_VIEW_COUNT * getPage(); i++ ) { const isSubscribed = getSubscribedPress().some( (press) =\u0026gt; press.index === list[i] ); const li = document.createElement(\u0026#34;li\u0026#34;); let img = document.createElement(\u0026#34;img\u0026#34;); img.setAttribute(\u0026#34;class\u0026#34;, \u0026#34;logo-img\u0026#34;); main_list_ul.appendChild(li); if (list.length \u0026gt; i) { img.setAttribute(\u0026#34;src\u0026#34;, `${PRESS_LOGO_IMG_PATH}${list[i]}.svg`); li.append(img); li.innerHTML += showSubscribeButton(isSubscribed); img = li.querySelector(\u0026#34;img\u0026#34;); li.addEventListener(\u0026#34;mouseover\u0026#34;, () =\u0026gt; handleEvent(\u0026#34;over\u0026#34;, img)); li.addEventListener(\u0026#34;mouseout\u0026#34;, () =\u0026gt; handleEvent(\u0026#34;out\u0026#34;, img)); } else { li.style.cursor = \u0026#34;default\u0026#34;; } } } 코드 설명 # 위의 코드는 어려움을 겪었던 코드이다. 여기서 문제가 생겼던 부분은 img 태그를 인자로 받았을 때 null로 받아져서 실행 함수에서 li, button 역시 마찬가지로 null이 돼서 해당 노드를 찾지 못한 것이다.\n문제가 발생한 이유는 하이라이트 표시한 li.innerHTML 부분 때문이다.\ninnerHTML # 우선 innerHTML에 대해 알아보자. innerHTML은 JavaScript에서 DOM 요소의 내부 HTML 콘텐츠에 접근하고 수정하는 속성이다. 이를 사용하여 요소의 자식 요소를 추가하거나 변경할 수 있다. html을 변경할 수 있기 때문에 템플릿 리터럴과 병행해서 사용하면 class, id 등 속성도 줄 수 있고 굉장히 편리하다. 하지만!\ninnerHTML을 사용할 때 주의해야 할 점은, 이 속성을 사용하면 기존의 내부 콘텐츠가 완전히 대체되기 때문에 해당 요소 안에 있던 이벤트 핸들러들이나 다른 DOM 요소들은 모두 사라지게 됩니다. 따라서 innerHTML을 사용하여 DOM을 변경할 때에는 주의하여 기존의 요소들이 어떻게 영향을 받는지를 고려해야 합니다.\n라고 gpt도 주의시킨다.\n문제 발생 이유 및 해결 방법 # innerHTML을 사용하면 이전에 생성한 요소를 포함하는 요소 innerHTML내부의 전체 콘텐츠가 다시 생성된다. 따라서 innerHTML 기본적으로 기존 요소가 제거되고 반환된 콘텐츠로 대체된다. li.innerHTML += showSubscribeButton(isSubscribed); 결과적으로 이전에 생성된 img요소는 더 이상 li요소에 존재하지 않는다. 따라서 다시 img = li.querySelector(\u0026quot;img\u0026quot;);를 통해 해당 노드를 찾아주었다.\n","date":"23 July 2023","permalink":"/posts/fe-newsstand/fe-newsstand6/","section":"Posts","summary":"FE 뉴스스탠드 (주말에도 이어서 \u0026hellip;) # 참고 fe-newsstand","title":"[현대 소프티어] FE 뉴스스탠드 #6"},{"content":"명탐정 코난: 흑철의 어영에서의 AI 기술 # 오늘 명탐정 코난: 흑철의 어영 영화를 봤는데 이번 영화에서 AI 기술이 많이 나와서 한번 알아보는 시간을 가지겠다. 미션 임파서블도 AI 기술이 나왔다는데 요즘 영화 트렌드인가보다. 스포일러에 최대한 주의하면서 기술에 집중하겠다.\n영화 속에서의 생장 인식 프로그램 # 어릴 때의 사진 데이터를 기반으로 몇 년 후의 모습을 유추해서 전 세계의 통합된 CCTV 데이터를 기반으로 사람을 찾는 기술이다. 아래의 줄거리 말 중 하나처럼 이 기술을 통해 여러 사건 해결에 도움을 줄 수 있다.\n일본과 유럽의 CCTV 정보를 확인할 수 있을 뿐 아니라, 장기 수배범이나 유괴당한 피해자를 전 세계에서 찾아낼 수 있는 ‘전연령 인식’이라는 획기적인 AI 기술을 개발 중이다.\n의문점 # 사실 보면서 여러 의문점이 있었다. 베르무트가 나중에 파훼법으로 (흠.. 스포일러인가) 닮은 사람으로 변장을 해서 기술의 신뢰도를 낮춘 장면이 있다. 여기서 생긴 의문이 그렇다면 오직 외관으로 이후의 모습을 예측하고 찾는다면 외관을 변형시킨다던가 아니면 쌍둥이 등 닮은 사람의 존재의 처리가 궁금해졌다. 뭐 영화는 영화로 봐야겠지만\n딥페이크 기술 # 스포일러 주의 영화 속에서 CCTV가 cg를 통해 딥페이크 기술이 적용된 것이라고 코난이 추리를 하는 장면이 있다.\n딥페이크란? # 작년에 코인이 유행할 때 일론 머스크와 관련해서 유튜브에 딥페이크 기술이 많이 등장했다. 딥페이크 기술은 과연 무엇일까?\n바로 딥러닝 기술을 이용해서 만든 가짜 이미지를 전체적으로 Deepfake 기술이라고 한다.\n동작 과정 # 데이터 수집: 합성하고자 하는 인물의 이미지나 동영상 데이터를 수집한다. 작중에서는 대상자가 내부 직원이라 충분한 양의 데이터가 있었다! 데이터 전처리: 수집한 데이터를 얼굴 영역만 추출하거나 필요한 크기로 변환한다. 인공지능 학습: GAN을 사용하여 생성자와 판별자를 학습시킨다. 생성자는 실제 얼굴과 비슷한 가짜 얼굴을 생성하도록 학습하고, 판별자는 진짜와 가짜를 잘 구분하도록 학습한다. 딥페이크 생성: 학습된 생성자를 사용하여 새로운 인물의 얼굴을 생성한다. 이 때, 다른 사람의 얼굴을 합성하여 딥페이크 영상을 만들 수 있습니다. 나는 생장 인식보다는 딥페이크 기술에 대해 관심이 더 갔는데 GAN 기술은 facebook의 AI 총괄을 맡은 ‘얀 르쿤’이 최근 10년 간 머신러닝 분야에서 가장 멋진 아이디어라고 할 만큼 혁신적인 기술이라고 한다. 확실히 강력한 기술이니만큼 악용될 소지가 많다. 작중에서와 같이 가짜 이미지를 통해 CCTV를 조작하는 등..\n동작 원리 # 이미지나 영상 처리는 사실 숫자로 이루어져 있다. 따라서 이러한 이미지나 영상을 수정하는 것은, 숫자를 변경하는 것과 같다. 그렇다면 숫자는 어떻게 변경하는가? 가장 중요한 것은, 행렬곱이다. 이미지 변경은 행렬의 연속적인 연산을 통해서 이루어진다. Fundamental math 수학적 연산 중에서 합성곱(convolution)는 영상 처리에 쓰이고 중요하다. 자세한 내용은 위키 참고\nCNN과 GAN CNN과 GAN은 딥러닝의 기본 개념이다. CNN은 Convolutional Neural Network로 convolution을 여러 겹 쌓은 딥러닝 구조를 뜻한다. GAN은 Generative Adversarial Network로, generator와 discriminator가 각각 지폐위조범과 경찰처럼 서로 잡고 잡히지 않기 위해 발달하는 원리를 차용한 딥러닝입니다. 따라서 이 기술들을 사용해서 동작 과정에서 말한 3번을 진행하면서 딥페이크를 생성한다.\n마치며 # 영화를 보면서 전공과 관련 기반 지식과 연관지어 생각하면서 재밌으면서도 현실성이 조금 없어서 비판적인 시각으로도 본 것 같다. 아쉬운 면이 다소 몇 가지 존재하지만 일반 영화보다는 전공 관련 지식이 많이 나와서 흥미로운 시선으로 보았다.\n","date":"22 July 2023","permalink":"/posts/study-in-movie/study-in-movie1/","section":"Posts","summary":"명탐정 코난: 흑철의 어영에서의 AI 기술 # 오늘 명탐정 코난: 흑철의 어영 영화를 봤는데 이번 영화에서 AI 기술이 많이 나와서 한번 알아보는 시간을 가지겠다.","title":"명탐정 코난: 흑철의 어영에서의 AI 기술"},{"content":"","date":null,"permalink":"/tags/%EC%98%81%ED%99%94-%EC%86%8D-%EA%B3%B5%EB%B6%80/","section":"Tags","summary":"","title":"영화 속 공부"},{"content":"","date":null,"permalink":"/categories/%EC%98%81%ED%99%94-%EC%86%8D-%EA%B3%B5%EB%B6%80/","section":"Categories","summary":"","title":"영화 속 공부"},{"content":"FE 뉴스스탠드 3주차 # 참고 fe-newsstand #3\nDone # 오늘은 3주차 마지막이지만 기획 리뷰와 세미나 시간으로 대부분 보내서 개발을 많이 하지 못했다. 주말동안 힘내서 기능 구현을 많이 해놔야겠다. 그런 의미로 오늘은 세미나와 코드리뷰에서 알게된 것들을 정리하겠다.\n세미나 #1 바닐라 JS를 이용한 컴포넌트 방식 개발 # 컴포넌트란 # 재사용이 가능한 각각의 독립된 모듈로, 컴포넌트들을 조합하여 화면을 구성할 수 있다. 현 시점에서의 웹 어플리케이션은 컴포넌트 단위로 설계한다.\n컴포넌트 방식 개발 # 한번 만들면 필요시 조금씩 바꿔서 재사용이 가능하다. 컴포넌트 기준으로 전체적인 구조 파악이 용이하다. 코드 중복 및 다른 모듈과의 의존성을 낮춰준다. 코드 수정시 해당 컴포넌트만 수정하기 때문에 유지 보수하기에 좋다. 바닐라 js 특징 # 컴포넌트별 state setState 호출 =\u0026gt; 현재 state가 업데이트되고 render된다. 단, 렌더링 범위를 지정해야한다는 단점이 있다. state, props를 통해 객체 이용을 관리한다. =\u0026gt; 순서 상관없이 원하는 key에 접근 가능하다. 컴포넌트 내부 함수는 화살표 함수로 구현한다. 화살표 함수 vs 일반 함수 # 화살표 함수와 일반 함수는 this 바인딩에 차이가 있다. 화살표 함수: 상위 객체 일반 함수: window 객체 (브라우저), global 객체(node.js) 최초 렌더링 시에만 실행 세미나 #2 웹페이지 이미지 최적화 # 이미지 최적화 기법 # 웹페이지 로딩 시간에는 js 파일과 이미지가 많은 영향을 끼친다. 따라서 티가 안나는 선에서 최대한 용량을 줄이면 속도 향상에 도움이 된다. 아래는 이미지 최적화 기법들이다.\nImage compression # 압축률을 높여 이미지용량 줄이기\nResizing # 사용자화면 사이즈에 맞게 이미지 사이즈 변경\nImage format # 용량이 작은 이미지 포맷으로 변경하기 webp 인터넷에서 이미지 로딩 시간 단축을 위해 google이 만든파일 포맷\nResponsive image 반응형 이미지 # pc는 4k를 쓸 일이 있지만 모바일은 없다. 따라서 이런 경우, media-query를 사용하여 반응형 이미지 사용하기!\nLazy Loading # 최대한 이미지 파일 늦게 불러오기 뷰포트 이내에 있거나 가까울때 이미지 불러오기 =\u0026gt; 처음에 웹페이지 불러올 때 빠르게 띄울 수 있음\nhtml =\u0026gt; img 태그에 loading = \u0026#34;lazy\u0026#34; js =\u0026gt; intersectionObserver Place holder # 레이아웃 시프트 이미지 로딩에 시간이 걸리면서 레이아웃이 이동되는 현상이다. 레이아웃 시프트는 placeholder 처리를 통해 해결할 수 있다.\nImage sprite # 이미지 에셋들을 모아서 한번에 불러오기\n해결 방법 # next.js 사용: next.js는 위의 이미지 최적화 관련된 기능들을 다 제공.\nnuxtImage\ncloudinary (프론트보다는 백엔드에서 처리하는 기법)\n마치며 # 코드 리뷰 회고 # 이벤트 핸들러는 무조건 분리하기 classList.remove, classList.add 안하고 =으로 변경할 수도 있다. 단, 싹 다 바뀌기 때문에 주의. await은 blocking 되기 때문에 관련 없는 것들은 동작되게 위로 옮기기 store\n상태 정의, 상태를 변경시켜주는 메소드가 있어야 한다.\nsubscribe 메소드: store 객체를 구독한다. 메소드가 없으면 상위 객체로 찾는다. =\u0026gt; prototype을 가지고 동작하도록\u0026hellip; ","date":"21 July 2023","permalink":"/posts/fe-newsstand/fe-newsstand5/","section":"Posts","summary":"FE 뉴스스탠드 3주차 # 참고 fe-newsstand #3","title":"[현대 소프티어] FE 뉴스스탠드 #5"},{"content":"FE 뉴스스탠드 3주차 # 참고 fe-newsstand #3 fe-newsstand 7.20\nDone # 어제 적은 피드백 일부를 반영했다. 오늘은 오전 시간(10~12시)을 제외하고 2시~5시까지 회사 설명회를 듣느라 개발에 시간을 많이 쏟지 못했다.\n[코드리뷰 피드백] 반영한 것은 취소선 표시\ncore은 개발자들이 볼 때 전체 페이지를 아우르는 느낌이기 때문에 조심해야 함 file 이름 상단에 모듈 역할 적기 getView의 경우에는 뷰를 얻어오는 것이 아니라 view mode를 얻어오는 것이기 때문에 getViewMode와 같이 변경 camel case와 _ 중 네이밍 일관성있게 통일시키기 swtich case에서 target 부분 명확하게 이름짓기 이미지, url들은 다 분리하기 주석, console.log도 커밋할 때 지우기 template literal은 html처럼 들여쓰기 등으로 보기 좋게 =\u0026gt; 만약 너무 길어지면 로직 빼내기 reducer 사용해보기 parentelement 같은 경우는 여러 번 중첩해서 쓰지 않기 =\u0026gt; DOM은 변경에 취약하기 때문에 많이 쓰면 파악 어려워짐 =\u0026gt; 이렇게 보니까 리팩토링을 많이 한다고 했는데 적게 했다. 하면서 고민이 생겼는데 이미지 url, 데이터 경로들을 constants.js로 분리하는 과정에 생긴 고민이다. 자세한 것은 아래(고민점)에 후술하겠다.\n경로 분리 이유 # 데이터나 이미지 같은 경우는 로컬이 아니라 서버에 저장되는데 분리하지 않을 경우 유지 보수가 어렵다. 따라서 개발 시에도 따로 분리해서 적어주는게 이후의 수정 및 개발을 위해서도 좋다고 한다.\nObject.freeze() # Object.freeze() 메서드는 객체를 변경할 수 없게 만든다.(read only) 아래의 경우와 같이 값을 바꾸려고 하면 오류를 던지는 것 같다.\nconst obj = { prop: 42, }; Object.freeze(obj); obj.prop = 33; // Throws an error in strict mode console.log(obj.prop); // Expected output: 42 Object.seal() # Object.freeze()를 공부하다가 Object.seal()이란 것도 존재하는 것을 알았다.\n// 1. 프로퍼티를 변경하는 경우 obj.a = 200; console.log(obj.a); // 200 // 2. 프로퍼티를 제거하는 경우 delete obj.a; console.log(obj.a); // 200 // 3. 새로운 프로퍼티를 추가하는 경우 obj.b = 500; console.log(obj.b); // undefined 무슨 차이인지 알겠는가? 결론적으로는 freeze가 제한이 더 많다. seal은 프로퍼티를 수정할 수 있지만 freeze는 불가능하다. 공통점으로는 전달된 객체들은 확장할 수 없게 되어 새로운 속성을 추가할 수 없다. 전달된 객체 내부의 모든 요소들은 구성 불가능하게 되어 삭제할 수 없다.\nAfter Refactoring # # constants.js (생략) export const ICON_IMG_PATH = \u0026#34;../assets/icons/\u0026#34;; export const DATA_PATH = \u0026#34;../data/\u0026#34;; Object.freeze({ DATE_UPDATE_TIME, RECENT_NEWS_CNT, ROLLING_WAIT_TIME, ROLLING_DIFF_TIME, FIRST_PAGE_NUM, LAST_PAGE_NUM, PRESS_CNT, SNACKBAR_WAIT_TIME, PRESS_LOGO_IMG_PATH, ICON_IMG_PATH, }); 마치며 # 고민점 # html의 이미지 태그의 경로는 어떻게 바꿀지 아직 고민중이다. app.js로 진입점을 하나로 설정해서 모듈들을 import하려고 했는데 html에서 constants들을 쓰자니 script로 불러와야 한다\u0026hellip; 어떡해야 할지 몰라서 아직 변경은 못했다.\n앞으로 할 일 # 집에 가서 이번주 한 일의 데모 영상을 촬영해야 한다. 길이는 1~5분 내외로 삽질한 것 내용을 위주로 설명해야 한다. 나는 아마 처음에 구독한 언론사를 콜백으로 변수를 관리하다가 이후 파라미터 관리가 복잡해져서 store와 옵저버 패턴으로 리팩토링한 과정을 설명할 것 같다.\n","date":"20 July 2023","permalink":"/posts/fe-newsstand/fe-newsstand4/","section":"Posts","summary":"FE 뉴스스탠드 3주차 # 참고 fe-newsstand #3 fe-newsstand 7.","title":"[현대 소프티어] FE 뉴스스탠드 #4"},{"content":"FE 뉴스스탠드 3주차 # 참고 fe-newsstand #3 fe-newsstand 7.19 fe-newsstand 7.19 Done # 오늘은 기능 구현보다는 주로 리팩토링에 힘을 썼다. 오전 시간(10~12시)에는 store와 view를 느슨하게 하기 위해 고민을 했다. 똑똑한 gpt와 블로그를 참고하여 store class를 만들고 observer 함수에 등록했다. 자세히 설명하겠다. (이해가 아직 다 된 것은 아니라 완벽하게 내 코드가 되진 않았다.)\nRefactoring # 옵저버 패턴으로 리팩토링을 진행하였다. 원래는 콜백 함수를 사용해서 값이 바뀌면 부모에게 전달해주었는데 코드가 많이 복잡했다. 옵저버는 1대 다 구조에 유리하고 상태가 변경되면 알아서 바꿔준다! (리덕스, PubSub 패턴과 유사) 중앙 집중식이라고 생각해서 store.js, observer.js와 getter.js는 core 폴더에 넣어주었다.\nStore # # store.js import { FIRST_PAGE_NUM } from \u0026#34;../constants/constants.js\u0026#34;; import { observable } from \u0026#34;./observer.js\u0026#34;; class Store { constructor() { this.state = observable({ mode: \u0026#34;light\u0026#34;, //추후 다크모드 view: \u0026#34;grid\u0026#34;, //그리드뷰 또는 리스트뷰 page: FIRST_PAGE_NUM, //현재 페이지 tabMode: \u0026#34;all\u0026#34;, //all 전체언론사 sub 구독한 언론사 subscribedPress: [\u0026#34;서울경제\u0026#34;, \u0026#34;데일리안\u0026#34;, \u0026#34;헤럴드경제\u0026#34;], }); } setState(newState) { for (const [key, value] of Object.entries(newState)) { if (!this.state.hasOwnProperty(key)) continue; this.state[key] = value; } } } export const store = new Store(); Observer # # observer.js let currentObserver = null; export const observe = (fn) =\u0026gt; { currentObserver = fn; fn(); currentObserver = null; }; export const observable = (obj) =\u0026gt; { Object.keys(obj).forEach((key) =\u0026gt; { let _value = obj[key]; const observers = new Set(); Object.defineProperty(obj, key, { get() { if (currentObserver) observers.add(currentObserver); return _value; }, set(value) { _value = value; observers.forEach((fn) =\u0026gt; fn()); }, }); }); return obj; }; observable은 객체의 속성에 get, set을 정의하여 관찰 가능한 상태로 만드는 함수이다. 즉, observable 함수를 사용하면 객체의 속성 값을 조회하고 할당할 때 특별한 동작을 추가하여 상태 변경을 감지할 수 있게 된다.\nobservable 함수를 사용하여 만든 객체의 속성은 Getter와 Setter가 적용되어, 속성의 값이 변경되거나 조회될 때 등록된 옵저버들이 자동으로 호출된다. 이를 통해 상태 변경을 감지하고, 등록된 옵저버들이 자동으로 업데이트되는 상태 관리를 할 수 있다.\n따라서 observable 함수를 사용하여 만든 store 객체는 관찰 가능한 상태를 가지며, 속성의 값이 변경되면 등록된 옵저버들이 자동으로 호출되어 상태 변경을 감지할 수 있다. 이를 통해 상태 조회 로직과 상태 변경 로직을 분리하여 코드를 더 모듈화하고, 상태 변화에 따른 반응을 자동화할 수 있다. (gpt의 설명 참고 ㅎㅁㅎ)\nGetter # # getter.js import { store } from \u0026#34;./store.js\u0026#34;; import { observe } from \u0026#34;./observer.js\u0026#34;; export function getMode() { return store.state.mode; } export function getView() { return store.state.view; } export function getPage() { return store.state.page; } export function getTabMode() { return store.state.tabMode; } export function getSubscribedPress() { return store.state.subscribedPress; } // 옵저버 등록 observe(getMode); observe(getView); observe(getPage); observe(getTabMode); getter는 store에 넣어도 된다. 하지만 store에는 순수한 데이터를 저장하고 어댑터 역할로 뷰에 전달하도록 필터 느낌으로 사용하고 싶다면 getter함수들을 따로 빼도 된다. 이 경우, test와 유지보수에 용이하다는 장점이 있다고 한다. store은 view에 dependency가 없고 메소드 정도는 있어도 된다. 하지만 순수할수록 좋다고 한다. 또한 옵저버 등록하는 부분들이 숨겨져 있는 것 같다고 크롱님께서 피드백을 주셨다. 명확하게 기능을 보이기 위해 어디에 위치시킬지 고민해봐야겠다.\n마치며 # 오늘 코드 피드백 시간에 3개 중 하나가 내 코드가 걸렸다. 덕분에 내 코드를 다시 돌아보고 이해하는 과정을 겪었다. 피드백을 반영할 것들을 메모해봤다.\n[스쿼드세션]\n상수에 freeze를 사용하면 read only가 되어서 값을 수정할 수 없다. 변하는 state는 대문자 사용하지 않기 [코드리뷰 피드백]\ncore은 개발자들이 볼 때 전체 페이지를 아우르는 느낌이기 때문에 조심해야 함 file 이름 상단에 모듈 역할 적기 getView의 경우에는 뷰를 얻어오는 것이 아니라 view mode를 얻어오는 것이기 때문에 getViewMode와 같이 변경 camel case와 _ 중 네이밍 일관성있게 통일시키기 swtich case에서 target 부분 명확하게 이름짓기 이미지, url들은 다 분리하기 주석, console.log도 커밋할 때 지우기 template literal은 html처럼 들여쓰기 등으로 보기 좋게 =\u0026gt; 만약 너무 길어지면 로직 빼내기 reducer 사용해보기 parentelement 같은 경우는 여러 번 중첩해서 쓰지 않기 =\u0026gt; DOM은 변경에 취약하기 때문에 많이 쓰면 파악 어려워짐 ","date":"19 July 2023","permalink":"/posts/fe-newsstand/fe-newsstand3/","section":"Posts","summary":"FE 뉴스스탠드 3주차 # 참고 fe-newsstand #3 fe-newsstand 7.","title":"[현대 소프티어] FE 뉴스스탠드 #3"},{"content":"FE 뉴스스탠드 3주차 # 참고 fe-newsstand #3 fe-newsstand 7.18 Feature List # 남은 기능 # (오늘 구현한 기능은 형광펜 표시)\n구독하기/해지하기 버튼\n리스트 뷰 메인 로고 썸네일에 마우스 호버 시 5% 확대\n구독한 언론사 탭 버튼 이벤트\n구독한 언론사 페이지 구현 + 구독/해지 이벤트\n그리드 뷰 마지막 페이지 언론사 로고 갯수 96개 아닐 때 그리드 표시\n다크모드 (추가 미션)\n개발한 기능 시연 # 구독/해지 이벤트를 구현하는 것까지 완료하였으나 지금 코드가 스파게티 코드 상태라 리팩토링을 빡세게 진행해야 한다.\n학습한 내용 # 주차 중 화요일, 수요일은 자바스크립트 관련 수업을 듣는다. 이번 수업에서는 scope, closure, 비동기, promise, json 객체 등 얼핏 알고 있었지만 자세히는 몰랐던 개념에 대해 알았다. 수업시간에 코드 예시를 실행하면서 원리를 알았지만 아직 내 지식으로 습득은 안 된 것 같아서 집에 돌아가면 다시 천천히 봐야겠다.\nScope # Scope chaining # 함수가 해당하는 값을 block -\u0026gt; closure 이런 식으로 올라가면서 scope를 올라가면서 찾는다.\nvar 함수 레벨 scope\nlet block 레벨 scope\n비동기와 동기 # const baseData = [1, 2, 3, 4, 5, 6, 100]; const asyncRun = (arr, fn) =\u0026gt; { for (var i = 0; i \u0026lt; arr.length; i++) { setTimeout(() =\u0026gt; fn(i), 1000); } }; asyncRun(baseData, (idx) =\u0026gt; console.log(idx)); 수업시간에 다룬 예제 코드 중 하나이다. 결과는 무엇일까?\n정답7이 7번 출력된다. 여기서 var를 let으로 변경하면? var는 함수 level scope, let은 block level scope이다. 따라서 var일 경우 참조값이 closure에 보관되어 있고 이 값은 for문을 7번 다 돈 후의 i이다. 즉 asyncRun의 지역변수 i (값은 7)를 참조한다. let의 경우에는 block level이기 때문에 각 for문 하나가 call stack에 쌓인다. Promise # let myFirstPromise = new Promise((resolve, reject) =\u0026gt; { setTimeout(() =\u0026gt; { resolve(\u0026#34;Success!\u0026#34;); }, 1000); }); myFirstPromise.then((successMessage) =\u0026gt; { console.log(\u0026#34;Yay! \u0026#34; + successMessage); }); 1. Promise객체 2. setTimeout 함수 3. setTimeout에 전달되는 콜백 4. then 함수 5. then에 전달되는 콜백 6. resolve 함수 7. Promise 함수에 전달되는 콜백 중에 실행 순서는 어떻게 될까?\n정답1 7 2 4 3 6 5 실행순서\npromsie 실행 \u0026gt; then 실행(콜백함수 promise에 등록) \u0026gt; 비동기 완료시 resolve 메서드 실행 \u0026gt; 콜백함수 실행\nthen은 동기함수이다. resolve의 신호가 있어야 콜백을 실행한다. fulfilled = 비동기 처리 끝났으니 실행하면 된다는 뜻!\npromise.then은 한 세트로 큐에 같이 들어간다. 또한 다른 큐에 쌓인 함수보다 우선순위가 높다.\n[번외] 화살표 함수 # 이번 수업시간은 아니고 크롱님(수업 담당하시는 분의 닉네임)께서 저번 주차에 숙제로 알아오라고 하셨다. (2번이나\u0026hellip;!)\n// 예시 함수 const exampleFunction = (parameter) =\u0026gt; { // 실행할 내용 }; // 이벤트 리스너 document.addEventListener(\u0026#34;click\u0026#34;, exampleFunction(parameter)); 위의 경우, 가독성 좋게 아래와 같이 변경할 수 있다.\n// 예시 함수 const exampleFunction = (parameter) =\u0026gt; () =\u0026gt; { // 실행할 내용 }; // 이벤트 리스너 document.addEventListener(\u0026#34;click\u0026#34;, exampleFunction(parameter)); 향후 계획 # 유용한 사이트를 많이 알았다. 오늘 학습한 call stack, event loop, queue와 앞으로 적용할 디자인 패턴 같은 내용이 사이트에 포함되어 있다.\n유용한 사이트 # JavaScript 개념 사이트 디자인 패턴 모음 추후 할 것 # 구독한 언론사 탭에서 해지하면 바로 없어지도록 구현하기 리팩토링\n\u0026ndash; store.js, 옵저버 패턴\n\u0026ndash; promise 객체 활용 ","date":"18 July 2023","permalink":"/posts/fe-newsstand/fe-newsstand2/","section":"Posts","summary":"FE 뉴스스탠드 3주차 # 참고 fe-newsstand #3 fe-newsstand 7.","title":"[현대 소프티어] FE 뉴스스탠드 #2"},{"content":"FE 뉴스스탠드 3주차 # 참고 fe-newsstand #3 fe-newsstand 7.17 3주차부터 블로그 시작하는 것이라 제목은 #1이다.\n프로젝트 설명 # 네이버 뉴스스탠드와 비슷한 기능을 하는 뉴스스탠드를 만드는 프로젝트다. 총 4주 기간동안 진행한다. 지금까지 2주가 지났고 오늘 3주차를 시작한다. 현재까지 구현한 기능은 다음과 같다.\n프로젝트 폴더 구조 트리 # fe-newsstand ├─ .DS_Store ├─ assets │ ├─ icons │ └─ images │ └─ logo │ ├─ dark │ └─ light ├─ css │ ├─ color.css │ ├─ index.css │ └─ reset.css ├─ data │ ├─ news.json │ ├─ press.json │ └─ recentNews.json ├─ index.html ├─ js │ ├─ app.js │ ├─ constants │ │ └─ constants.js │ ├─ sections │ │ ├─ header.js │ │ ├─ mainView.js │ │ └─ recentNews.js │ └─ utils │ ├─ autoRolling.js │ ├─ changeView.js │ ├─ checkPage.js │ ├─ getDate.js │ ├─ makeGridView.js │ ├─ makeListView.js │ └─ reload.js └─ readme.md Feature list # 개발 완료한 기능 # [기본 화면] - [x] 메인 로고 클릭 시 새로고침 - [x] 시스템 날짜 표현 [최신 뉴스 영역] - [x] 최신 뉴스 5초마다 5개 자동 롤링 - [x] 좌우 영역 1초 차이 롤링 - [x] 마우스 호버 시 롤링 일시정지 [그리드 뷰] - [x] 새로고침 시 언론사 로고 랜덤 표시 - [x] 첫 페이지, 마지막 페이지 버튼 disable - [x] 뷰 방식 변경 - [x] 마우스 호버 시 구독하기 버튼 표시 [리스트 뷰] - [x] 클릭한 카테고리의 현재 언론사 순서와 총 언론사 수 표시 - [x] 버튼 클릭 시 해당 카테고리의 다음 언론사로 넘어가기 - [x] 20s간 프로그레스 바 진행 후, 다음 언론사로 넘어가기 남은 기능 # (오늘 구현한 기능은 형광펜 표시)\n구독하기/해지하기 버튼 리스트 뷰 메인 로고 썸네일에 마우스 호버 시 5% 확대 구독한 언론사 탭 버튼 이벤트 구독한 언론사 페이지 구현 \u0026lt;- 구현하다가 개발 시간이 끝났다. 그리드 뷰 마지막 페이지 언론사 로고 갯수 96개 아닐 때 그리드 표시 다크모드 (추가 미션) 개발한 기능 시연 # 원래 카테고리 바에 프로그레스 바 진행이 나타나야 하는데 개발 도중에 끝나서 캡쳐를 못했다.\n어려웠던 점 # 문제 상황 # 이벤트 위임을 적용하고 싶어서 리스트뷰전체에서 이벤트를 받았다. 리스트뷰에서 언론사 구독하기 클릭이벤트를 등록할 때 페이지가 증가할수록 그 수만큼 이벤트가 중첩됐다.\n시행착오 #1 # removeEventListener를 통해 이벤트를 제거하려고도 해봤으나 제거하면 클릭을 한번밖에 못함\n시행착오 #2 # 각 언론사 뉴스 정보를 세분화해서 그려주는 drawPressInfo.js 파일에서 각각의 구독하기 버튼에 제한해서 클릭이벤트를 적용\n해결 코드 # # pressNewsInfo.js 이벤트 리스너 등록한 부분 export function drawPressInfo(category_news, subscribedPress, press) { const press_news = document.querySelector(\u0026#34;.press-news\u0026#34;); press_news.innerHTML = `\u0026lt;div class=\u0026#34;press-info\u0026#34;\u0026gt; \u0026lt;img id=\u0026#34;press-logo\u0026#34; alt=\u0026#34;press-logo\u0026#34; src=\u0026#34;${category_news.src}\u0026#34; /\u0026gt; \u0026lt;span class=\u0026#34;edit-date\u0026#34;\u0026gt;${category_news.edit_date} 편집\u0026lt;/span\u0026gt; \u0026lt;div class=\u0026#34;sub\u0026#34;\u0026gt; \u0026lt;button class=\u0026#34;sub subscribe\u0026#34;\u0026gt; \u0026lt;img src=\u0026#34;../assets/icons/plus.svg\u0026#34; /\u0026gt; \u0026lt;span\u0026gt;구독하기\u0026lt;/span\u0026gt; \u0026lt;/button\u0026gt; \u0026lt;button class=\u0026#34;sub cancel\u0026#34;\u0026gt; \u0026lt;img src=\u0026#34;../assets/icons/closed.svg\u0026#34; /\u0026gt; \u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt;`; showSubscribeButton(subscribedPress, press); const newDiv = document.createElement(\u0026#34;div\u0026#34;); newDiv.classList.add(\u0026#34;news-content\u0026#34;); press_news.appendChild(newDiv); const sub_btn = document.querySelector(\u0026#34;.press-info .sub\u0026#34;); sub_btn.addEventListener(\u0026#34;click\u0026#34;, (e) =\u0026gt; handleClick(e, subscribedPress, press) ); } 언론사 정보를 그려주는 함수에서 버튼에 클릭 이벤트를 등록했다. 버튼이 클릭되면 아래의 함수가 실행된다. 아래의 함수는 버튼이 구독한 상태에서 누른 버튼인지, 아닌 상태에서 누른 버튼인지를 해당 버튼의 클래스로 조건문을 판별한다. cancel이 클래스에 포함되어 있을 경우, 현재 리스트 뷰의 버튼은 해지하기 버튼이므로 구독한 상태를 의미한다. 따라서 해당 버튼이 눌렸을 때에는 해지 처리를 아닌 경우에는 구독 처리를 해주었다.\n# pressNewsInfo.js 클릭 이벤트가 실행시켜주는 함수 function handleClick(e, subscribedPress, press) { const btn_target = e.target.closest(\u0026#34;button\u0026#34;); const press_news = document.querySelector(\u0026#34;.press-news\u0026#34;); const newDiv = document.createElement(\u0026#34;div\u0026#34;); if (btn_target) { console.log(subscribedPress, subscribedPress.includes(press)); if (btn_target.classList.contains(\u0026#34;cancel\u0026#34;)) { console.log(\u0026#34;해지\u0026#34;); newDiv.classList.add(\u0026#34;popup\u0026#34;, \u0026#34;alert\u0026#34;); newDiv.innerHTML = ` \u0026lt;div class=\u0026#34;message\u0026#34;\u0026gt;\u0026lt;span class=\u0026#34;press\u0026#34;\u0026gt;${press}\u0026lt;/span\u0026gt;을(를)\\n구독해지하시겠습니까?\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;buttons\u0026#34;\u0026gt; \u0026lt;button class=\u0026#34;btn-yes\u0026#34;\u0026gt;예, 해지합니다\u0026lt;/button\u0026gt; \u0026lt;button class=\u0026#34;btn-no\u0026#34;\u0026gt;아니오\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt;`; press_news.appendChild(newDiv); const btn = document.querySelector(\u0026#34;.buttons\u0026#34;); btn.addEventListener(\u0026#34;click\u0026#34;, (e) =\u0026gt; checkAnswer(e, subscribedPress, press) ); } else { console.log(\u0026#34;현재 언론사\u0026#34;, press); subscribedPress = [...subscribedPress, press]; newDiv.classList.add(\u0026#34;popup\u0026#34;, \u0026#34;snackbar\u0026#34;); newDiv.textContent = \u0026#34;내가 구독한 언론사에 추가되었습니다.\u0026#34;; press_news.appendChild(newDiv); showSubscribeButton(subscribedPress, press); parentCallback(subscribedPress); newDiv.addEventListener(\u0026#34;animationend\u0026#34;, handleAnimationEnd); }}} 아직 리팩토링 전이라 매우 코드가 보기 힘들다. console.log도 안 지운 코드 (\u0026hellip;)\n향후 계획 # 코드 리뷰하면서 같은 팀원 분 중 한 분이 고수신데 store.js, 옵저버 패턴을 사용했다. 지금 건드렸다간 버그 투성이일 것 같아서 못했지만 기능 구현을 완료하고 리팩토링을 할 때 한 번 사용하고 싶다. 내일은 내가 구독한 언론사 탭을 구현해야 한다. 이 탭은 기본 틀은 카테고리 별 뉴스와 같아서 카테고리를 그려주는 함수의 파라미터를 손보다가 개발 시간이 끝나서 현재 지금 안 돌아가는 상태로 존재한다. ㅎㅎ 내일은 버그를 고쳐야겠다. ","date":"17 July 2023","permalink":"/posts/fe-newsstand/fe-newsstand1/","section":"Posts","summary":"FE 뉴스스탠드 3주차 # 참고 fe-newsstand #3 fe-newsstand 7.","title":"[현대 소프티어] FE 뉴스스탠드 #1"},{"content":"Hugo와 Github page를 이용한 블로그 제작 # 블로그 제작 결심 # 원래도 공부하고 시간이 지나면 까먹고 같은 것을 찾아보는 것을 깨닫고 새롭게 안 것을 기록해야 할 필요성을 느꼈다. 생각만 하고 흐지부지 되던 차에 과 방학 행사 중 하나로 블로그 챌린지를 진행한다고 해서 블로그를 개발하게 되었다. 또한 4학년 여름 방학 2개월동안 현대 소프티어 부트캠프를 수료하는데 여기서 배운 것들을 기록하면 정말 좋을 것 같았다.\nHugo를 선택한 이유 # jekyll\n- ruby 기반 - 한글 레퍼런스가 많다 - 빌드 시 시간이 오래 걸린다. (이게 가장 큰 단점인듯) Hugo - Golang 기반 - 가장 빠르다. - 한글 레퍼런스가 적다. Hexo\n- JavaScript 기반 - 속도는 jekyll보다 빠르고 hugo보다 느리다. - 중국 레퍼런스가 많다. 이렇게 세 가지가 유명한 것 같다. 검색해보니까 jekyll에서 hugo로 넘어간 글이 보이고 hugo가 빌드 시 빠르다는 것, 그리고 테마를 구경하고 마음에 든 것이 있어서 hugo를 선택했다.\nHugo 설치 # 설치는 os에 따라 다르다. 현재 2개월 간 시한부 맥북 신세라 (\u0026hellip;) brew install을 통해 설치해주었다. 윈도우는 본인이 사용하고 싶은 테마가 SCSS를 포함하고 있으면 확장 버전을 따로 설치해야 하는 것 같았다.\n# hugo 설치 $ brew install hugo # hugo 버전 확인 $ hugo version Git 레포지토리 생성 # Git 레포지토리는 총 2개 생성해주면 된다.\n블로그 포스트 저장용 렌더링용 페이지 (github.io) 2번의 경우에는 원하는 레포지토리 이름이 있더라도 {username}/github.io로 하고 배포한 다음, 이름을 수정해야 한다. Hugo 블로그 프로젝트 생성 # 원하는 프로젝트 이름으로 hugo 프로젝트 hugo new site blog를 생성한다. 나의 경우에는 blog로 프로젝트 이름을 지정했다.\nHugo 테마 적용 # 테마마다 다운로드하는 방법이 친절하게 설명되어 있다. 나의 경우에는 congo 테마를 사용했다. 여기서부터는 Go 언어도 설치가 된 상태여야 한다. Go 역시 brew를 통해 설치했다.\nHugo 프로젝트 디렉토리 구성 # 테마마다 디렉토리 구조가 다른데 형식(이름)을 같게 해주어야 한다. 아래는 내가 적용한 테마의 기본 구조이다.\n. ├── assets │ └── img │ └── author.jpg ├── config │ └── _default ├── content │ ├── _index.md │ ├── about.md │ └── posts │ ├── _index.md │ ├── first-post.md │ └── another-post │ ├── aardvark.jpg │ └── index.md └── themes └── congo 이후로는 샘플과 깃허브 코드들을 보면서 config/_default/params.toml등을 원하는 설정으로 변경했다.\nGithub 연동 # Repository 연결 # 1. 포스트 관리용으로 만든 레포지토리와 연결 # git remote add origin \u0026lt;repo 주소\u0026gt;\n2. 호스팅용 레포지토리와 연결 # git submodule add -b main \u0026lt;repo 주소\u0026gt; public\n포스트 업로드 # 이후 포스트를 쓰고 hugo -t \u0026lt;테마이름\u0026gt;을 하면 public에 html 파일이 생성된다. 생성된 public 디렉토리에 들어가서 변경된 부분들을 commit 해주면 본인의 github page 주소에 반영이 된다.\nHugo와 Github page를 이용한 블로그 제작 총평 # 블로그 제작 후기 # 테마가 예쁘고 다크모드 구현, 태그, 검색 등 다양한 기능이 들어있어서 좋았다.\n내가 고른 테마는 다국어 번역 기능을 지원하지만 한국어를 지원해주지 않았다. 나중에 시간적 여유가 생긴다면 한국어로 pr을 날려봐도 좋을 것 같다.\n향후 계획 # 자동 배포를 통한 자동화 도메인을 구매 후 적용 (가능하다면) ","date":"15 July 2023","permalink":"/posts/create-blog/create-blog/","section":"Posts","summary":"Hugo와 Github page를 이용한 블로그 제작 # 블로그 제작 결심 # 원래도 공부하고 시간이 지나면 까먹고 같은 것을 찾아보는 것을 깨닫고 새롭게 안 것을 기록해야 할 필요성을 느꼈다.","title":"Hugo 블로그 제작기"}]