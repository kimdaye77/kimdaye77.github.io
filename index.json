[{"content":"","date":null,"permalink":"/","section":"","summary":"","title":""},{"content":"Type script 공부 #1 # 노마드코더 강의 링크 오늘은 어제 뉴스스탠드 기능 구현을 완료했으므로 예외 처리 간단한 거 3개만 해주고 8월에 있는 프로젝트를 위해 노마드코더의 타입스크립트 강의를 봤다. 강의를 보고 클론 코딩하면서 메모하고 싶은 개념들을 아래에 정리하겠다.\nstring interpolation # 하하 이거는 전에도 interpolation이 무슨 뜻일까? 궁금해서 검색해봤는데 정리를 안하니까 까먹은 개념이다. 정확히 말하면 알던 개념이지만 이것을 string interpolation이라고 하는지 몰랐다. 이제는 기억하기 위해 적어놓는다.\n# string interpolation ${변수명} 문자열 인터폴레이션 은 해당 값으로 대치된 결과를 생성하는 과정이다. 위의 코드에서는 해당 변수명의 값으로 대체된다. (비슷하게 변수 인터폴레이션, 변수 대체, 변수 확장라고도 한다.) js에서 굉장히 많이 쓴다..!\n타입스크립트 # 대망의 타입스크립트..! 말로만 듣고 처음 본다. 타입스크립트는 자바스크립트를 기반으로 한 프로그래밍 언어로 자바스크립트와는 다른 언어이다. 하지만 기반으로 했기 때문에 몇 가지 차이점을 제외하고는 비슷하다. 타입스크립트의 두드러지는 특징으로는 다음과 같다.\nstrongly-typed 언어 # 이름에서부터 알다싶이 타입스크립트는 코드를 작성할 때 타입을 명시해야한다. 그러면 타입스크립트는 프로그래밍 언어가 작동하기 전에 type을 확인한다. 작동 원리 브라우저는 js밖에 이해하지 못하므로 ts는 컴파일하면 js로 바뀐다. 따라서 protection은 코드 작동 전 발생한다. 코드 작성 전에 타입이 맞는지 보고 문제가 없으면 js 코드를 리턴한 것을 브라우저가 띄어준다.\n번외 # js에서 쓰는 라이브러리들은 타입들을 ts가 알 수 있게 해줘야한다. 이때, @types를 사용해서 ts에게 타입을 알려줄 수 있다. 거대한 github repository 유명한 npm 라이브러리를 가지고 있는 저장소로 여기서 라이브러리나 패키지의 type definition 을 알려준다.\n타입스크립트 장점 # props 오타 등의 실수를 알 수 있다. 타입 틀렸을 때 컴파일 전에 알 수 있다. ?? Null 병합 연산자 (Nullish coalescing operator) # ?? 앞에 값이 null이거나 undefined이면 오른쪽 값을, 그렇지 않으면 왼쪽 값을 반환하는 논리연산자\n# 예시 null ?? \u0026#34;hello\u0026#34; // \u0026#34;hello\u0026#34; undefined ?? \u0026#34;hello\u0026#34; // \u0026#34;hello\u0026#34; \u0026#34;hi\u0026#34; ?? \u0026#34;hello\u0026#34; // “hi\u0026#34; currentTarget과 target 차이 # https://choonse.com/2022/01/14/605/ typescript에서 reactjs는 currentTarget 사용을 택했다. ES6 문법 # https://nomadcoders.co/react-masterclass/lectures/3336 -몰랐던 신기한 es6 문법\nconst { currentTarget: { value }, } = event; event안 curentTarget안에 value의 값을 기존 이름 그대로 value 라는 변수를 만든다. const value = event.currentTarget.value 랑 같은 의미이다. 왜 사용할까? currentTarget안에서 value, tagName, width, id 등 여러 개 를 가져오고 싶을 때 장점이 있다.\n# 기존 문법 const value = event.currentTarget.value; const tagName = event.currentTarget.tagName; const width = event.currentTarget.width; const id = event.currentTarget.id; 이거를 이렇게 바꿔 쓸 수 있다.\n# ES6 문법 const { currentTarget: {value, tagName, width, id} } = event; ","date":"27 July 2023","permalink":"/posts/types-cript/type-script1/","section":"Posts","summary":"Type script 공부 #1 # 노마드코더 강의 링크 오늘은 어제 뉴스스탠드 기능 구현을 완료했으므로 예외 처리 간단한 거 3개만 해주고 8월에 있는 프로젝트를 위해 노마드코더의 타입스크립트 강의를 봤다.","title":"[TS] Type script 공부 #1"},{"content":"","date":null,"permalink":"/posts/","section":"Posts","summary":"","title":"Posts"},{"content":"","date":null,"permalink":"/tags/","section":"Tags","summary":"","title":"Tags"},{"content":"","date":null,"permalink":"/tags/%EB%85%B8%EB%A7%88%EB%93%9C%EC%BD%94%EB%8D%94/","section":"Tags","summary":"","title":"노마드코더"},{"content":"","date":null,"permalink":"/tags/%EB%A6%AC%EC%95%A1%ED%8A%B8/","section":"Tags","summary":"","title":"리액트"},{"content":"","date":null,"permalink":"/tags/%ED%83%80%EC%9E%85%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8/","section":"Tags","summary":"","title":"타입스크립트"},{"content":"FE 뉴스스탠드 4주차 # 참고 fe-newsstand #4 fe-newsstand 7.26 버그 수정 fe-newsstand 7.26 리스트뷰 랜덤 구현 fe-newsstand 7.26 예외 처리\n구현한 기능 # 기능 구현\n리스트뷰 랜덤순서 구독한 언론사 탭 누르면 리스트뷰 디폴트 설정 예외 처리 및 버그 수정\n25개일때 해지하고 페이지 처리 여러 개 해지되는 현상 해결 오버플로우 뒤에 위치한 언론사 위치 조정 첫번째 페이지에서 이전 버튼 클릭시 마지막 페이지 그리드뷰 버튼에만 클릭이벤트 범위 적용하기 구독한 언론사 아무것도 없을때 -\u0026gt; alert 처리 25개일때 해지하기 페이지 처리 여러개 해지되는 현상 해결 To do list # 다른 곳 선택 시 스낵바 에니메이션 제거 리팩토링 시연 영상 # 에휴 항상 시연 영상 찍다가 버그를 발견한다. 전에 고친 버그인데 잘못 수정하다가 다시 발생한 것 같다. To do. 다른 곳 선택하면 스낵바 애니메이션 종료 후 구독한 언론사 탭으로 이동하는 이벤트 제거\n어려웠던 점 # 오늘은 어제 고치기로 생각한 해지가 여러번 되는 현상을 수정하느라 애먹었다. (7/26) 참고 해지 여러번 되는 버그 해결\nBefore # # subscribePress.js export function handleSubscribe(_press) { const isSubscribed = getSubscribedPress().some( (press) =\u0026gt; press.name === _press.name ); document.addEventListener(\u0026#34;click\u0026#34;, (e) =\u0026gt; checkRange(e)); deletePopupAndAnimation(); closeAllPopups(); //구독한 상태에서 누를 경우 if (isSubscribed) { store.setState({ currentPress: _press }); const alert = document.querySelector(\u0026#34;.alert\u0026#34;); alert.style.display = \u0026#34;block\u0026#34;; const press_msg = alert.querySelector(\u0026#34;.press\u0026#34;); press_msg.innerHTML = `${getCurrentPress().name}`; const btn = document.querySelector(\u0026#34;.buttons\u0026#34;); btn.addEventListener(\u0026#34;click\u0026#34;, (e) =\u0026gt; { checkAnswer(e, _press); alert.style.display = \u0026#34;none\u0026#34;; }); } //구독하지 않았을 때 =\u0026gt; 구독됨 else { const updatedSubscribedPress = [...getSubscribedPress(), _press]; store.setState({ subscribedPress: updatedSubscribedPress }); const snackbar = document.querySelector(\u0026#34;.snackbar\u0026#34;); snackbar.style.display = \u0026#34;block\u0026#34;; document.addEventListener(\u0026#34;animationend\u0026#34;, (e) =\u0026gt; handleAnimationEnd(e, _press) ); //구독한 상태로 바뀜 getView() === \u0026#34;grid\u0026#34; ? showGridView() : showListView(); }} 원래 버그 해결 전에는 각각 showGridView와 showListView에서 구독 또는 해지 버튼을 클릭할 경우에 subscribe.js 파일에서 handleSubscribe 함수를 불러와서 실행하였다. 이렇게 실행된 handleSubscribe는 각각 구독인지/해지인지 판단하고 해당하는 이벤트를 등록해주었다. 이렇게하니 해지하기 버튼을 선택하지 않고 곧바로 다른 언론사의 해지하기 버튼을 누르면 이벤트가 중첩돼서 삭제가 중첩되었다. 따라서 다음 코드와 같이 대대적으로 함수를 이동시켰다.\nAfter # # MainView.js function attachEventListner() { document.addEventListener(\u0026#34;click\u0026#34;, (e) =\u0026gt; handleClick(e)); document.addEventListener(\u0026#34;animationend\u0026#34;, (e) =\u0026gt; handleAnimationEnd(e)); const btn = document.querySelector(\u0026#34;.buttons\u0026#34;); btn.addEventListener(\u0026#34;click\u0026#34;, (e) =\u0026gt; { checkAnswer(e); });} 위의 코드는 버그를 고친 후이다. 이벤트 등록을 view 최상위인 MainView.js에서 등록을 해주었다. 이렇게 하니 애니메이션 중첩 현상이 사라졌다!\n코드리뷰 # 오늘은 수요일이기 때문에 크롱님께서 다른 분들의 코드를 보며 리뷰해주시는 시간을 가졌다.\n비동기 함수 병렬 처리 비동기 함수에는 await, promise 등이 있다. 비동기 함수를 쓰다보면 api 여러개 써야할 때가 있다. 이럴 때에는 await을 여러 번 사용하는 경우 순차적으로 실행이 다 된 후에 코드들이 진행되기 때문에 일종의 blocking 현상이 발생한다. 이럴 때에는 promise.all를 통해 해결할 수 있다. promise.all을 사용하고 이후 .then을 통해 병렬 처리 해주면 된다. 그러면 비동기 함수들을 병렬 처리할 수 있다. Delegation 크롱님께서 저번 시간과 이번 시간에 Delegation에 대해 말씀해주셔서 뭔지 궁금해서 검색해보았다. 간단히 말하면 디자인 패턴의 일부로 어떤 helper 객체를 이용하여 데이터를 제공하거나 특정 작업을 수행하는 것을 위임하는 패턴을 말한다. 마치며 # 이번주까지 완성해야 했던 뉴스스탠드의 기능 완료를 끝내서 너무 뿌듯하다. 언제 완성하지 막막했던 것이 엊그제같은데 ㅠㅠ 이제 남은 것은 시연하면서 알게 된 재발생한 버그+리팩토링이다. 하 리팩토링 어디서부터 건들여야 할 지\u0026hellip; 오늘은 짜투리 시간에 Styled Component도 공부해봤다. 잠깐 맛만 봤는데 신세계다.\n","date":"26 July 2023","permalink":"/posts/fe-newsstand/fe-newsstand9/","section":"Posts","summary":"FE 뉴스스탠드 4주차 # 참고 fe-newsstand #4 fe-newsstand 7.","title":"[현대 소프티어] FE 뉴스스탠드 #9"},{"content":"","date":null,"permalink":"/tags/newsstand/","section":"Tags","summary":"","title":"newsstand"},{"content":"","date":null,"permalink":"/tags/%ED%94%84%EB%A1%A0%ED%8A%B8%EC%97%94%EB%93%9C/","section":"Tags","summary":"","title":"프론트엔드"},{"content":"","date":null,"permalink":"/tags/%ED%98%84%EB%8C%80%EC%86%8C%ED%94%84%ED%8B%B0%EC%96%B4/","section":"Tags","summary":"","title":"현대소프티어"},{"content":"FE 뉴스스탠드 4주차 # 참고 fe-newsstand #4 fe-newsstand 7.25 구독하기 기능 관련 상세 사항 구현 구현한 기능 (7/25) # 글자수 많은 언론사 alert 버그 문제 해결 이미지 호버시 확대 5% =\u0026gt; 리스트뷰 구독한 언론사에도 적용 선택한 카테고리 외 마우스 호버 시 밑줄 타이포그래피 스타일 파일 분리 및 적용 구독한 언론사 탭 카테고리 스크롤도 가능하도록 구현 팝업창 한 번 만들고 display로 컨트롤 [리팩토링] 함수 모듈화 =\u0026gt; drawCategory, mainview 학습 내용 # prototype # \u0026quot;abc\u0026quot;.charAt === \u0026quot;dfg\u0026quot;.charAt을 하면 결과값은 true로 나온다. prototype에 있기 때문에 메소드는 동일한 메소드를 가리킨다. 더 자세히 알아보자.\n자바 스크립트는 모든 것이 객체다.\n라는 말이 있다. 아래의 예시를 보면\nclass Foo { constructor(name) { this.name = name; } getName() { return this.name; } } 을 하고 마찬가지로 new Foo(\u0026quot;crong\u0026quot;).getName === new Foo(\u0026quot;newcrong\u0026quot;).getName을 하면 true가 결과로 나온다. 하지만\nclass Foo { constructor(name) { this.name = name; this.getName = () =\u0026gt; { return this.name; }; } } 위와 같이 constructor 안에 getName 메소드를 넣으면 결과는 false이다. 이유는 바로 자바 스크립트의 prototype과 관련이 있다. js에는 상속의 개념이 없다. 비슷한 개념으로 native api(prototype)이 있다. 이는 객체가 생성되면 상위 메소드를 share하는 개념이다. 최상위 object까지 prototype chain 연결을 통해 toString까지 최후에는 다다른다. extends를 통해 사이에 새로운 prototype을 만들 수도 있다. cf) 문자열은 객체가 아닌 primitive type이지만 \u0026quot;string\u0026quot;.method이렇게 .을 붙이는 순간 객체가 된다. Wrapper Object\n이벤트 위임 # 이벤트 위임은 이벤트 버블링(전파)을 방지해준다.\nevent.target은 밖을 눌러도 leaf node를 가리키기 때문에 이벤트 위임이 가능하다. 위임으로 구현하면 메모리의 이벤트 핸들러 갯수를 감소해서 메모리 효율성을 증가할 수 있다. stopPropagation()이라고 이벤트 위임 외에도 이벤트 버블링을 방지하는 메소드도 존재한다.\n[번외] 리액트는 이벤트위임을 직접해준다. (onClick 이벤트를 등록하면 이벤트 리스너들은 document로 올라가서 모이고. 클릭이벤트가 실행되면 분기별로 등록한 이벤트를 처리해준다.)\nstate 관리 # 싱글페이징 구조는 클라이언트가 상태를 가지면 안 되기 때문에 상태 관리 별도로 필요\nFlux 아키텍쳐 MVC도 가능(옵저버패턴) Mediator 패턴(state를 둬서 전달자처럼 상태가 바뀐 것을 알려준다.) 그 외 여러가지가 존재한다.\nstore는 관련있는 애들끼리 모아놓기! 아니면 관련 없는 함수가 쓸데없이 실행된다. react는 diff 알고리즘이 있어서 렌더링 변경시 이전 상태와 현재 상태를 비교해서 달라질 경우에만 DOM 부분을 렌더링한다. 마치며 # 이제 리스트뷰 새로고침 시 랜덤 구현과 드래그 할 때 뒷부분이 가려지는 문제를 해결하면 얼추 기능 완성에 가까워진 것 같다. 마지막에 버그를 발견했는데 못 고치고 집을 가서 슬프다.. 내일 아침에 바로 해야겠다. To do. 25개 이상일 때 삭제하면 가끔 여러개 삭제됨. ","date":"25 July 2023","permalink":"/posts/fe-newsstand/fe-newsstand8/","section":"Posts","summary":"FE 뉴스스탠드 4주차 # 참고 fe-newsstand #4 fe-newsstand 7.","title":"[현대 소프티어] FE 뉴스스탠드 #8"},{"content":"FE 뉴스스탠드 4주차 # 참고 fe-newsstand #4 fe-newsstand 7.24 그리드뷰 구독 클릭 이벤트 fe-newsstand 7.24 다크모드 구현 fe-newsstand 7.24 구독한 언론사 드래그 기능 구현\n구현한 기능 # 리스트 뷰 메인 로고 썸네일에 마우스 호버 시 5% 확대 다크모드 (추가 미션) 카테고리 추가영역 노출 처리(선택) 리스트뷰 뉴스 제목 호버 시 밑줄 표시 To do list # 언론사 글자 수가 길 때 다음 줄로 넘어가는 문제 (알럿) 리스트뷰 랜덤 순서 구현 오버플로우 뒤에 위치한 언론사 위치 조정 리팩토링 시연 영상 # 시연 영상 찍다가 버그 발견했다. 구독한 언론사 탭 부분 이미지는 확대가 호버 시 안 되는 것 같다.\n어려웠던 점 # 오늘은 이벤트를 주로 다뤄서 이벤트 관련 부분에서 어려움을 많이 겪었다. (7/24)\n1. 스낵바 애니메이션 종료 후, 2번 실행되는 문제 # css 애니메이션이 fade-in, fade-out 2번 적용되기 때문에 2번 실행되는 것이었다. 디버깅 때 찾느라 시간이 많이 걸렸다. 찾고나서는 간단하게 animationEnd이벤트 리스너로 event.animationName이 fade-out일 때에만 구독한 언론사로 넘어가게 구현했다. 2. 해지하기 이벤트 리스너가 한번만 실행됨 # 개발자 도구를 이용해서 html 소스를 뜯어보니 보면 이전 popup(snackbar, alert)이 계속 겹쳐진 것이었다. 따라서 클릭을 해도 이벤트가 등록되지 않은 버튼이 눌려서 버튼 클릭 이벤트가 실행되지 않았다. 일단 document.querySelector(\u0026quot;popup\u0026quot;)을 통해 있다면 removeChild를 통해 제거했으나 같은 팀원분께서 display.none을 통한 것이 cost가 절감될 것이라고 해서 리팩토링 때 할 예정이다. 3. mouse up, click 구분 # 오늘 구현한 기능 중 구독한 언론사가 많으면 드래그를 통해 스크롤 할 수 있게 하는 기능이 있다. 여기서 드래그가 끝날 때의 up을 할 때 click 이벤트도 같이 실행되었다. tabContainer.addEventListener(\u0026#34;mousedown\u0026#34;, (e) =\u0026gt; { isDragging = true; startScrollX = e.pageX + tabContainer.scrollLeft; tabContent.style.cursor = \u0026#34;grabbing\u0026#34;; startClickX = e.pageX; }); window.addEventListener(\u0026#34;mousemove\u0026#34;, (e) =\u0026gt; { if (!isDragging) return; e.preventDefault(); const scrollX = startScrollX - e.pageX; tabContainer.scrollLeft = scrollX; }); window.addEventListener(\u0026#34;mouseup\u0026#34;, (e) =\u0026gt; { isDragging = false; tabContent.style.cursor = \u0026#34;grab\u0026#34;; if (startClickX === e.pageX) { handleClick(e); } }); startClickX는 드래그 시작 시의 X 좌표 값을 기억하는 변수로, 나중에 클릭 이벤트와 드래그 이벤트를 구분하는데 사용된다. if (startClickX === e.pageX) { ... }는 드래그와 클릭 이벤트를 구분하기 위해 드래그 이벤트가 발생하기 전과 마우스를 누르고 뗀 지점의 X 좌표를 비교한다. 만약 드래그 없이 마우스를 클릭했다 떼었다면, handleClick(e) 함수를 호출한다.\n++ 드래그 이벤트도 따로 빼면 좋을 것 같다.\n","date":"24 July 2023","permalink":"/posts/fe-newsstand/fe-newsstand7/","section":"Posts","summary":"FE 뉴스스탠드 4주차 # 참고 fe-newsstand #4 fe-newsstand 7.","title":"[현대 소프티어] FE 뉴스스탠드 #7"},{"content":"FE 뉴스스탠드 (주말에도 이어서 \u0026hellip;) # 참고 fe-newsstand\nDone # 오늘은 주말이지만 열심히 코딩을 달렸다. 왜냐? 곧 8월에 프로젝트를 들어가기 전에 미션은 빨리 끝내면 좋을 것 같아서\u0026hellip; 지금 블로그 글을 쓰고 있는 와중에 너무 졸리다. 구현한 기능은 아래와 같이 할 일 목록들 중 5개 정도 구현했다.\n오늘 구현하면서 DOM에 대해 더 알게 된 것 같다.\nDOM # 우선 DOM에 대해 무엇인지 간단하게 짚고 가겠다.\nDocument Object Model # HTML 문서에 접근하기 위한 일종의 인터페이스이다. DOM은 계층적으로 정보를 표현하는 노드 트리 구조이다. 위의 그림과 같이 우리가 흔히 알고있는 div, span 등은 노드이다. 여기서 text 정보 또한 노드인 것을 유념해야 한다. html 정보들을 바꾸고 싶을 때 우리는 DOM API를 많이 사용하는데 다음과 같은 것들이 있다.\nDOM API # # 노드 선택 querySelector(), querySelectorAll() getElementById() # 노드 탐색 parentNode(), firstChild() # 노드 생성 및 삭제 createElement() appendChild() removeChild() # 노드 정보 변경 innerHTML, innerText; DOM API는 매우 편리하지만 변경함에 따라 이벤트가 작동이 안 될수도 있다는 것을 알아야 한다\u0026hellip;\n코드에서 DOM API # # 실행 함수 function handleEvent(event, img) { const li = img.parentNode; const button = img.nextElementSibling; switch (event) { case \u0026#34;over\u0026#34;: img.style.display = \u0026#34;none\u0026#34;; button.style.display = \u0026#34;flex\u0026#34;; li.style.backgroundColor = \u0026#34;var(--surface-alt)\u0026#34;; break; case \u0026#34;out\u0026#34;: img.style.display = \u0026#34;block\u0026#34;; button.style.display = \u0026#34;none\u0026#34;; li.style.backgroundColor = \u0026#34;var(--surface-default)\u0026#34;; break; default: break; } } # 이벤트 핸들러 export function showGridView() { (생략) for ( let i = PRESS_VIEW_COUNT * (getPage() - 1); i \u0026lt; PRESS_VIEW_COUNT * getPage(); i++ ) { const isSubscribed = getSubscribedPress().some( (press) =\u0026gt; press.index === list[i] ); const li = document.createElement(\u0026#34;li\u0026#34;); let img = document.createElement(\u0026#34;img\u0026#34;); img.setAttribute(\u0026#34;class\u0026#34;, \u0026#34;logo-img\u0026#34;); main_list_ul.appendChild(li); if (list.length \u0026gt; i) { img.setAttribute(\u0026#34;src\u0026#34;, `${PRESS_LOGO_IMG_PATH}${list[i]}.svg`); li.append(img); li.innerHTML += showSubscribeButton(isSubscribed); img = li.querySelector(\u0026#34;img\u0026#34;); li.addEventListener(\u0026#34;mouseover\u0026#34;, () =\u0026gt; handleEvent(\u0026#34;over\u0026#34;, img)); li.addEventListener(\u0026#34;mouseout\u0026#34;, () =\u0026gt; handleEvent(\u0026#34;out\u0026#34;, img)); } else { li.style.cursor = \u0026#34;default\u0026#34;; } } } 코드 설명 # 위의 코드는 어려움을 겪었던 코드이다. 여기서 문제가 생겼던 부분은 img 태그를 인자로 받았을 때 null로 받아져서 실행 함수에서 li, button 역시 마찬가지로 null이 돼서 해당 노드를 찾지 못한 것이다.\n문제가 발생한 이유는 하이라이트 표시한 li.innerHTML 부분 때문이다.\ninnerHTML # 우선 innerHTML에 대해 알아보자. innerHTML은 JavaScript에서 DOM 요소의 내부 HTML 콘텐츠에 접근하고 수정하는 속성이다. 이를 사용하여 요소의 자식 요소를 추가하거나 변경할 수 있다. html을 변경할 수 있기 때문에 템플릿 리터럴과 병행해서 사용하면 class, id 등 속성도 줄 수 있고 굉장히 편리하다. 하지만!\ninnerHTML을 사용할 때 주의해야 할 점은, 이 속성을 사용하면 기존의 내부 콘텐츠가 완전히 대체되기 때문에 해당 요소 안에 있던 이벤트 핸들러들이나 다른 DOM 요소들은 모두 사라지게 됩니다. 따라서 innerHTML을 사용하여 DOM을 변경할 때에는 주의하여 기존의 요소들이 어떻게 영향을 받는지를 고려해야 합니다.\n라고 gpt도 주의시킨다.\n문제 발생 이유 및 해결 방법 # innerHTML을 사용하면 이전에 생성한 요소를 포함하는 요소 innerHTML내부의 전체 콘텐츠가 다시 생성된다. 따라서 innerHTML 기본적으로 기존 요소가 제거되고 반환된 콘텐츠로 대체된다. li.innerHTML += showSubscribeButton(isSubscribed); 결과적으로 이전에 생성된 img요소는 더 이상 li요소에 존재하지 않는다. 따라서 다시 img = li.querySelector(\u0026quot;img\u0026quot;);를 통해 해당 노드를 찾아주었다.\n","date":"23 July 2023","permalink":"/posts/fe-newsstand/fe-newsstand6/","section":"Posts","summary":"FE 뉴스스탠드 (주말에도 이어서 \u0026hellip;) # 참고 fe-newsstand","title":"[현대 소프티어] FE 뉴스스탠드 #6"},{"content":"명탐정 코난: 흑철의 어영에서의 AI 기술 # 오늘 명탐정 코난: 흑철의 어영 영화를 봤는데 이번 영화에서 AI 기술이 많이 나와서 한번 알아보는 시간을 가지겠다. 미션 임파서블도 AI 기술이 나왔다는데 요즘 영화 트렌드인가보다. 스포일러에 최대한 주의하면서 기술에 집중하겠다.\n영화 속에서의 생장 인식 프로그램 # 어릴 때의 사진 데이터를 기반으로 몇 년 후의 모습을 유추해서 전 세계의 통합된 CCTV 데이터를 기반으로 사람을 찾는 기술이다. 아래의 줄거리 말 중 하나처럼 이 기술을 통해 여러 사건 해결에 도움을 줄 수 있다.\n일본과 유럽의 CCTV 정보를 확인할 수 있을 뿐 아니라, 장기 수배범이나 유괴당한 피해자를 전 세계에서 찾아낼 수 있는 ‘전연령 인식’이라는 획기적인 AI 기술을 개발 중이다.\n의문점 # 사실 보면서 여러 의문점이 있었다. 베르무트가 나중에 파훼법으로 (흠.. 스포일러인가) 닮은 사람으로 변장을 해서 기술의 신뢰도를 낮춘 장면이 있다. 여기서 생긴 의문이 그렇다면 오직 외관으로 이후의 모습을 예측하고 찾는다면 외관을 변형시킨다던가 아니면 쌍둥이 등 닮은 사람의 존재의 처리가 궁금해졌다. 뭐 영화는 영화로 봐야겠지만\n딥페이크 기술 # 스포일러 주의 영화 속에서 CCTV가 cg를 통해 딥페이크 기술이 적용된 것이라고 코난이 추리를 하는 장면이 있다.\n딥페이크란? # 작년에 코인이 유행할 때 일론 머스크와 관련해서 유튜브에 딥페이크 기술이 많이 등장했다. 딥페이크 기술은 과연 무엇일까?\n바로 딥러닝 기술을 이용해서 만든 가짜 이미지를 전체적으로 Deepfake 기술이라고 한다.\n동작 과정 # 데이터 수집: 합성하고자 하는 인물의 이미지나 동영상 데이터를 수집한다. 작중에서는 대상자가 내부 직원이라 충분한 양의 데이터가 있었다! 데이터 전처리: 수집한 데이터를 얼굴 영역만 추출하거나 필요한 크기로 변환한다. 인공지능 학습: GAN을 사용하여 생성자와 판별자를 학습시킨다. 생성자는 실제 얼굴과 비슷한 가짜 얼굴을 생성하도록 학습하고, 판별자는 진짜와 가짜를 잘 구분하도록 학습한다. 딥페이크 생성: 학습된 생성자를 사용하여 새로운 인물의 얼굴을 생성한다. 이 때, 다른 사람의 얼굴을 합성하여 딥페이크 영상을 만들 수 있습니다. 나는 생장 인식보다는 딥페이크 기술에 대해 관심이 더 갔는데 GAN 기술은 facebook의 AI 총괄을 맡은 ‘얀 르쿤’이 최근 10년 간 머신러닝 분야에서 가장 멋진 아이디어라고 할 만큼 혁신적인 기술이라고 한다. 확실히 강력한 기술이니만큼 악용될 소지가 많다. 작중에서와 같이 가짜 이미지를 통해 CCTV를 조작하는 등..\n동작 원리 # 이미지나 영상 처리는 사실 숫자로 이루어져 있다. 따라서 이러한 이미지나 영상을 수정하는 것은, 숫자를 변경하는 것과 같다. 그렇다면 숫자는 어떻게 변경하는가? 가장 중요한 것은, 행렬곱이다. 이미지 변경은 행렬의 연속적인 연산을 통해서 이루어진다. Fundamental math 수학적 연산 중에서 합성곱(convolution)는 영상 처리에 쓰이고 중요하다. 자세한 내용은 위키 참고\nCNN과 GAN CNN과 GAN은 딥러닝의 기본 개념이다. CNN은 Convolutional Neural Network로 convolution을 여러 겹 쌓은 딥러닝 구조를 뜻한다. GAN은 Generative Adversarial Network로, generator와 discriminator가 각각 지폐위조범과 경찰처럼 서로 잡고 잡히지 않기 위해 발달하는 원리를 차용한 딥러닝입니다. 따라서 이 기술들을 사용해서 동작 과정에서 말한 3번을 진행하면서 딥페이크를 생성한다.\n마치며 # 영화를 보면서 전공과 관련 기반 지식과 연관지어 생각하면서 재밌으면서도 현실성이 조금 없어서 비판적인 시각으로도 본 것 같다. 아쉬운 면이 다소 몇 가지 존재하지만 일반 영화보다는 전공 관련 지식이 많이 나와서 흥미로운 시선으로 보았다.\n","date":"22 July 2023","permalink":"/posts/study-in-movie/study-in-movie1/","section":"Posts","summary":"명탐정 코난: 흑철의 어영에서의 AI 기술 # 오늘 명탐정 코난: 흑철의 어영 영화를 봤는데 이번 영화에서 AI 기술이 많이 나와서 한번 알아보는 시간을 가지겠다.","title":"명탐정 코난: 흑철의 어영에서의 AI 기술"},{"content":"","date":null,"permalink":"/tags/%EC%98%81%ED%99%94-%EC%86%8D-%EA%B3%B5%EB%B6%80/","section":"Tags","summary":"","title":"영화 속 공부"},{"content":"FE 뉴스스탠드 3주차 # 참고 fe-newsstand #3\nDone # 오늘은 3주차 마지막이지만 기획 리뷰와 세미나 시간으로 대부분 보내서 개발을 많이 하지 못했다. 주말동안 힘내서 기능 구현을 많이 해놔야겠다. 그런 의미로 오늘은 세미나와 코드리뷰에서 알게된 것들을 정리하겠다.\n세미나 #1 바닐라 JS를 이용한 컴포넌트 방식 개발 # 컴포넌트란 # 재사용이 가능한 각각의 독립된 모듈로, 컴포넌트들을 조합하여 화면을 구성할 수 있다. 현 시점에서의 웹 어플리케이션은 컴포넌트 단위로 설계한다.\n컴포넌트 방식 개발 # 한번 만들면 필요시 조금씩 바꿔서 재사용이 가능하다. 컴포넌트 기준으로 전체적인 구조 파악이 용이하다. 코드 중복 및 다른 모듈과의 의존성을 낮춰준다. 코드 수정시 해당 컴포넌트만 수정하기 때문에 유지 보수하기에 좋다. 바닐라 js 특징 # 컴포넌트별 state setState 호출 =\u0026gt; 현재 state가 업데이트되고 render된다. 단, 렌더링 범위를 지정해야한다는 단점이 있다. state, props를 통해 객체 이용을 관리한다. =\u0026gt; 순서 상관없이 원하는 key에 접근 가능하다. 컴포넌트 내부 함수는 화살표 함수로 구현한다. 화살표 함수 vs 일반 함수 # 화살표 함수와 일반 함수는 this 바인딩에 차이가 있다. 화살표 함수: 상위 객체 일반 함수: window 객체 (브라우저), global 객체(node.js) 최초 렌더링 시에만 실행 세미나 #2 웹페이지 이미지 최적화 # 이미지 최적화 기법 # 웹페이지 로딩 시간에는 js 파일과 이미지가 많은 영향을 끼친다. 따라서 티가 안나는 선에서 최대한 용량을 줄이면 속도 향상에 도움이 된다. 아래는 이미지 최적화 기법들이다.\nImage compression # 압축률을 높여 이미지용량 줄이기\nResizing # 사용자화면 사이즈에 맞게 이미지 사이즈 변경\nImage format # 용량이 작은 이미지 포맷으로 변경하기 webp 인터넷에서 이미지 로딩 시간 단축을 위해 google이 만든파일 포맷\nResponsive image 반응형 이미지 # pc는 4k를 쓸 일이 있지만 모바일은 없다. 따라서 이런 경우, media-query를 사용하여 반응형 이미지 사용하기!\nLazy Loading # 최대한 이미지 파일 늦게 불러오기 뷰포트 이내에 있거나 가까울때 이미지 불러오기 =\u0026gt; 처음에 웹페이지 불러올 때 빠르게 띄울 수 있음\nhtml =\u0026gt; img 태그에 loading = \u0026#34;lazy\u0026#34; js =\u0026gt; intersectionObserver Place holder # 레이아웃 시프트 이미지 로딩에 시간이 걸리면서 레이아웃이 이동되는 현상이다. 레이아웃 시프트는 placeholder 처리를 통해 해결할 수 있다.\nImage sprite # 이미지 에셋들을 모아서 한번에 불러오기\n해결 방법 # next.js 사용: next.js는 위의 이미지 최적화 관련된 기능들을 다 제공.\nnuxtImage\ncloudinary (프론트보다는 백엔드에서 처리하는 기법)\n마치며 # 코드 리뷰 회고 # 이벤트 핸들러는 무조건 분리하기 classList.remove, classList.add 안하고 =으로 변경할 수도 있다. 단, 싹 다 바뀌기 때문에 주의. await은 blocking 되기 때문에 관련 없는 것들은 동작되게 위로 옮기기 store\n상태 정의, 상태를 변경시켜주는 메소드가 있어야 한다.\nsubscribe 메소드: store 객체를 구독한다. 메소드가 없으면 상위 객체로 찾는다. =\u0026gt; prototype을 가지고 동작하도록\u0026hellip; ","date":"21 July 2023","permalink":"/posts/fe-newsstand/fe-newsstand5/","section":"Posts","summary":"FE 뉴스스탠드 3주차 # 참고 fe-newsstand #3","title":"[현대 소프티어] FE 뉴스스탠드 #5"},{"content":"FE 뉴스스탠드 3주차 # 참고 fe-newsstand #3 fe-newsstand 7.20\nDone # 어제 적은 피드백 일부를 반영했다. 오늘은 오전 시간(10~12시)을 제외하고 2시~5시까지 회사 설명회를 듣느라 개발에 시간을 많이 쏟지 못했다.\n[코드리뷰 피드백] 반영한 것은 취소선 표시\ncore은 개발자들이 볼 때 전체 페이지를 아우르는 느낌이기 때문에 조심해야 함 file 이름 상단에 모듈 역할 적기 getView의 경우에는 뷰를 얻어오는 것이 아니라 view mode를 얻어오는 것이기 때문에 getViewMode와 같이 변경 camel case와 _ 중 네이밍 일관성있게 통일시키기 swtich case에서 target 부분 명확하게 이름짓기 이미지, url들은 다 분리하기 주석, console.log도 커밋할 때 지우기 template literal은 html처럼 들여쓰기 등으로 보기 좋게 =\u0026gt; 만약 너무 길어지면 로직 빼내기 reducer 사용해보기 parentelement 같은 경우는 여러 번 중첩해서 쓰지 않기 =\u0026gt; DOM은 변경에 취약하기 때문에 많이 쓰면 파악 어려워짐 =\u0026gt; 이렇게 보니까 리팩토링을 많이 한다고 했는데 적게 했다. 하면서 고민이 생겼는데 이미지 url, 데이터 경로들을 constants.js로 분리하는 과정에 생긴 고민이다. 자세한 것은 아래(고민점)에 후술하겠다.\n경로 분리 이유 # 데이터나 이미지 같은 경우는 로컬이 아니라 서버에 저장되는데 분리하지 않을 경우 유지 보수가 어렵다. 따라서 개발 시에도 따로 분리해서 적어주는게 이후의 수정 및 개발을 위해서도 좋다고 한다.\nObject.freeze() # Object.freeze() 메서드는 객체를 변경할 수 없게 만든다.(read only) 아래의 경우와 같이 값을 바꾸려고 하면 오류를 던지는 것 같다.\nconst obj = { prop: 42, }; Object.freeze(obj); obj.prop = 33; // Throws an error in strict mode console.log(obj.prop); // Expected output: 42 Object.seal() # Object.freeze()를 공부하다가 Object.seal()이란 것도 존재하는 것을 알았다.\n// 1. 프로퍼티를 변경하는 경우 obj.a = 200; console.log(obj.a); // 200 // 2. 프로퍼티를 제거하는 경우 delete obj.a; console.log(obj.a); // 200 // 3. 새로운 프로퍼티를 추가하는 경우 obj.b = 500; console.log(obj.b); // undefined 무슨 차이인지 알겠는가? 결론적으로는 freeze가 제한이 더 많다. seal은 프로퍼티를 수정할 수 있지만 freeze는 불가능하다. 공통점으로는 전달된 객체들은 확장할 수 없게 되어 새로운 속성을 추가할 수 없다. 전달된 객체 내부의 모든 요소들은 구성 불가능하게 되어 삭제할 수 없다.\nAfter Refactoring # # constants.js (생략) export const ICON_IMG_PATH = \u0026#34;../assets/icons/\u0026#34;; export const DATA_PATH = \u0026#34;../data/\u0026#34;; Object.freeze({ DATE_UPDATE_TIME, RECENT_NEWS_CNT, ROLLING_WAIT_TIME, ROLLING_DIFF_TIME, FIRST_PAGE_NUM, LAST_PAGE_NUM, PRESS_CNT, SNACKBAR_WAIT_TIME, PRESS_LOGO_IMG_PATH, ICON_IMG_PATH, }); 마치며 # 고민점 # html의 이미지 태그의 경로는 어떻게 바꿀지 아직 고민중이다. app.js로 진입점을 하나로 설정해서 모듈들을 import하려고 했는데 html에서 constants들을 쓰자니 script로 불러와야 한다\u0026hellip; 어떡해야 할지 몰라서 아직 변경은 못했다.\n앞으로 할 일 # 집에 가서 이번주 한 일의 데모 영상을 촬영해야 한다. 길이는 1~5분 내외로 삽질한 것 내용을 위주로 설명해야 한다. 나는 아마 처음에 구독한 언론사를 콜백으로 변수를 관리하다가 이후 파라미터 관리가 복잡해져서 store와 옵저버 패턴으로 리팩토링한 과정을 설명할 것 같다.\n","date":"20 July 2023","permalink":"/posts/fe-newsstand/fe-newsstand4/","section":"Posts","summary":"FE 뉴스스탠드 3주차 # 참고 fe-newsstand #3 fe-newsstand 7.","title":"[현대 소프티어] FE 뉴스스탠드 #4"},{"content":"FE 뉴스스탠드 3주차 # 참고 fe-newsstand #3 fe-newsstand 7.19 fe-newsstand 7.19 Done # 오늘은 기능 구현보다는 주로 리팩토링에 힘을 썼다. 오전 시간(10~12시)에는 store와 view를 느슨하게 하기 위해 고민을 했다. 똑똑한 gpt와 블로그를 참고하여 store class를 만들고 observer 함수에 등록했다. 자세히 설명하겠다. (이해가 아직 다 된 것은 아니라 완벽하게 내 코드가 되진 않았다.)\nRefactoring # 옵저버 패턴으로 리팩토링을 진행하였다. 원래는 콜백 함수를 사용해서 값이 바뀌면 부모에게 전달해주었는데 코드가 많이 복잡했다. 옵저버는 1대 다 구조에 유리하고 상태가 변경되면 알아서 바꿔준다! (리덕스, PubSub 패턴과 유사) 중앙 집중식이라고 생각해서 store.js, observer.js와 getter.js는 core 폴더에 넣어주었다.\nStore # # store.js import { FIRST_PAGE_NUM } from \u0026#34;../constants/constants.js\u0026#34;; import { observable } from \u0026#34;./observer.js\u0026#34;; class Store { constructor() { this.state = observable({ mode: \u0026#34;light\u0026#34;, //추후 다크모드 view: \u0026#34;grid\u0026#34;, //그리드뷰 또는 리스트뷰 page: FIRST_PAGE_NUM, //현재 페이지 tabMode: \u0026#34;all\u0026#34;, //all 전체언론사 sub 구독한 언론사 subscribedPress: [\u0026#34;서울경제\u0026#34;, \u0026#34;데일리안\u0026#34;, \u0026#34;헤럴드경제\u0026#34;], }); } setState(newState) { for (const [key, value] of Object.entries(newState)) { if (!this.state.hasOwnProperty(key)) continue; this.state[key] = value; } } } export const store = new Store(); Observer # # observer.js let currentObserver = null; export const observe = (fn) =\u0026gt; { currentObserver = fn; fn(); currentObserver = null; }; export const observable = (obj) =\u0026gt; { Object.keys(obj).forEach((key) =\u0026gt; { let _value = obj[key]; const observers = new Set(); Object.defineProperty(obj, key, { get() { if (currentObserver) observers.add(currentObserver); return _value; }, set(value) { _value = value; observers.forEach((fn) =\u0026gt; fn()); }, }); }); return obj; }; observable은 객체의 속성에 get, set을 정의하여 관찰 가능한 상태로 만드는 함수이다. 즉, observable 함수를 사용하면 객체의 속성 값을 조회하고 할당할 때 특별한 동작을 추가하여 상태 변경을 감지할 수 있게 된다.\nobservable 함수를 사용하여 만든 객체의 속성은 Getter와 Setter가 적용되어, 속성의 값이 변경되거나 조회될 때 등록된 옵저버들이 자동으로 호출된다. 이를 통해 상태 변경을 감지하고, 등록된 옵저버들이 자동으로 업데이트되는 상태 관리를 할 수 있다.\n따라서 observable 함수를 사용하여 만든 store 객체는 관찰 가능한 상태를 가지며, 속성의 값이 변경되면 등록된 옵저버들이 자동으로 호출되어 상태 변경을 감지할 수 있다. 이를 통해 상태 조회 로직과 상태 변경 로직을 분리하여 코드를 더 모듈화하고, 상태 변화에 따른 반응을 자동화할 수 있다. (gpt의 설명 참고 ㅎㅁㅎ)\nGetter # # getter.js import { store } from \u0026#34;./store.js\u0026#34;; import { observe } from \u0026#34;./observer.js\u0026#34;; export function getMode() { return store.state.mode; } export function getView() { return store.state.view; } export function getPage() { return store.state.page; } export function getTabMode() { return store.state.tabMode; } export function getSubscribedPress() { return store.state.subscribedPress; } // 옵저버 등록 observe(getMode); observe(getView); observe(getPage); observe(getTabMode); getter는 store에 넣어도 된다. 하지만 store에는 순수한 데이터를 저장하고 어댑터 역할로 뷰에 전달하도록 필터 느낌으로 사용하고 싶다면 getter함수들을 따로 빼도 된다. 이 경우, test와 유지보수에 용이하다는 장점이 있다고 한다. store은 view에 dependency가 없고 메소드 정도는 있어도 된다. 하지만 순수할수록 좋다고 한다. 또한 옵저버 등록하는 부분들이 숨겨져 있는 것 같다고 크롱님께서 피드백을 주셨다. 명확하게 기능을 보이기 위해 어디에 위치시킬지 고민해봐야겠다.\n마치며 # 오늘 코드 피드백 시간에 3개 중 하나가 내 코드가 걸렸다. 덕분에 내 코드를 다시 돌아보고 이해하는 과정을 겪었다. 피드백을 반영할 것들을 메모해봤다.\n[스쿼드세션]\n상수에 freeze를 사용하면 read only가 되어서 값을 수정할 수 없다. 변하는 state는 대문자 사용하지 않기 [코드리뷰 피드백]\ncore은 개발자들이 볼 때 전체 페이지를 아우르는 느낌이기 때문에 조심해야 함 file 이름 상단에 모듈 역할 적기 getView의 경우에는 뷰를 얻어오는 것이 아니라 view mode를 얻어오는 것이기 때문에 getViewMode와 같이 변경 camel case와 _ 중 네이밍 일관성있게 통일시키기 swtich case에서 target 부분 명확하게 이름짓기 이미지, url들은 다 분리하기 주석, console.log도 커밋할 때 지우기 template literal은 html처럼 들여쓰기 등으로 보기 좋게 =\u0026gt; 만약 너무 길어지면 로직 빼내기 reducer 사용해보기 parentelement 같은 경우는 여러 번 중첩해서 쓰지 않기 =\u0026gt; DOM은 변경에 취약하기 때문에 많이 쓰면 파악 어려워짐 ","date":"19 July 2023","permalink":"/posts/fe-newsstand/fe-newsstand3/","section":"Posts","summary":"FE 뉴스스탠드 3주차 # 참고 fe-newsstand #3 fe-newsstand 7.","title":"[현대 소프티어] FE 뉴스스탠드 #3"},{"content":"FE 뉴스스탠드 3주차 # 참고 fe-newsstand #3 fe-newsstand 7.18 Feature List # 남은 기능 # (오늘 구현한 기능은 형광펜 표시)\n구독하기/해지하기 버튼\n리스트 뷰 메인 로고 썸네일에 마우스 호버 시 5% 확대\n구독한 언론사 탭 버튼 이벤트\n구독한 언론사 페이지 구현 + 구독/해지 이벤트\n그리드 뷰 마지막 페이지 언론사 로고 갯수 96개 아닐 때 그리드 표시\n다크모드 (추가 미션)\n개발한 기능 시연 # 구독/해지 이벤트를 구현하는 것까지 완료하였으나 지금 코드가 스파게티 코드 상태라 리팩토링을 빡세게 진행해야 한다.\n학습한 내용 # 주차 중 화요일, 수요일은 자바스크립트 관련 수업을 듣는다. 이번 수업에서는 scope, closure, 비동기, promise, json 객체 등 얼핏 알고 있었지만 자세히는 몰랐던 개념에 대해 알았다. 수업시간에 코드 예시를 실행하면서 원리를 알았지만 아직 내 지식으로 습득은 안 된 것 같아서 집에 돌아가면 다시 천천히 봐야겠다.\nScope # Scope chaining # 함수가 해당하는 값을 block -\u0026gt; closure 이런 식으로 올라가면서 scope를 올라가면서 찾는다.\nvar 함수 레벨 scope\nlet block 레벨 scope\n비동기와 동기 # const baseData = [1, 2, 3, 4, 5, 6, 100]; const asyncRun = (arr, fn) =\u0026gt; { for (var i = 0; i \u0026lt; arr.length; i++) { setTimeout(() =\u0026gt; fn(i), 1000); } }; asyncRun(baseData, (idx) =\u0026gt; console.log(idx)); 수업시간에 다룬 예제 코드 중 하나이다. 결과는 무엇일까?\n정답7이 7번 출력된다. 여기서 var를 let으로 변경하면? var는 함수 level scope, let은 block level scope이다. 따라서 var일 경우 참조값이 closure에 보관되어 있고 이 값은 for문을 7번 다 돈 후의 i이다. 즉 asyncRun의 지역변수 i (값은 7)를 참조한다. let의 경우에는 block level이기 때문에 각 for문 하나가 call stack에 쌓인다. Promise # let myFirstPromise = new Promise((resolve, reject) =\u0026gt; { setTimeout(() =\u0026gt; { resolve(\u0026#34;Success!\u0026#34;); }, 1000); }); myFirstPromise.then((successMessage) =\u0026gt; { console.log(\u0026#34;Yay! \u0026#34; + successMessage); }); 1. Promise객체 2. setTimeout 함수 3. setTimeout에 전달되는 콜백 4. then 함수 5. then에 전달되는 콜백 6. resolve 함수 7. Promise 함수에 전달되는 콜백 중에 실행 순서는 어떻게 될까?\n정답1 7 2 4 3 6 5 실행순서\npromsie 실행 \u0026gt; then 실행(콜백함수 promise에 등록) \u0026gt; 비동기 완료시 resolve 메서드 실행 \u0026gt; 콜백함수 실행\nthen은 동기함수이다. resolve의 신호가 있어야 콜백을 실행한다. fulfilled = 비동기 처리 끝났으니 실행하면 된다는 뜻!\npromise.then은 한 세트로 큐에 같이 들어간다. 또한 다른 큐에 쌓인 함수보다 우선순위가 높다.\n[번외] 화살표 함수 # 이번 수업시간은 아니고 크롱님(수업 담당하시는 분의 닉네임)께서 저번 주차에 숙제로 알아오라고 하셨다. (2번이나\u0026hellip;!)\n// 예시 함수 const exampleFunction = (parameter) =\u0026gt; { // 실행할 내용 }; // 이벤트 리스너 document.addEventListener(\u0026#34;click\u0026#34;, exampleFunction(parameter)); 위의 경우, 가독성 좋게 아래와 같이 변경할 수 있다.\n// 예시 함수 const exampleFunction = (parameter) =\u0026gt; () =\u0026gt; { // 실행할 내용 }; // 이벤트 리스너 document.addEventListener(\u0026#34;click\u0026#34;, exampleFunction(parameter)); 향후 계획 # 유용한 사이트를 많이 알았다. 오늘 학습한 call stack, event loop, queue와 앞으로 적용할 디자인 패턴 같은 내용이 사이트에 포함되어 있다.\n유용한 사이트 # JavaScript 개념 사이트 디자인 패턴 모음 추후 할 것 # 구독한 언론사 탭에서 해지하면 바로 없어지도록 구현하기 리팩토링\n\u0026ndash; store.js, 옵저버 패턴\n\u0026ndash; promise 객체 활용 ","date":"18 July 2023","permalink":"/posts/fe-newsstand/fe-newsstand2/","section":"Posts","summary":"FE 뉴스스탠드 3주차 # 참고 fe-newsstand #3 fe-newsstand 7.","title":"[현대 소프티어] FE 뉴스스탠드 #2"},{"content":"FE 뉴스스탠드 3주차 # 참고 fe-newsstand #3 fe-newsstand 7.17 3주차부터 블로그 시작하는 것이라 제목은 #1이다.\n프로젝트 설명 # 네이버 뉴스스탠드와 비슷한 기능을 하는 뉴스스탠드를 만드는 프로젝트다. 총 4주 기간동안 진행한다. 지금까지 2주가 지났고 오늘 3주차를 시작한다. 현재까지 구현한 기능은 다음과 같다.\n프로젝트 폴더 구조 트리 # fe-newsstand ├─ .DS_Store ├─ assets │ ├─ icons │ └─ images │ └─ logo │ ├─ dark │ └─ light ├─ css │ ├─ color.css │ ├─ index.css │ └─ reset.css ├─ data │ ├─ news.json │ ├─ press.json │ └─ recentNews.json ├─ index.html ├─ js │ ├─ app.js │ ├─ constants │ │ └─ constants.js │ ├─ sections │ │ ├─ header.js │ │ ├─ mainView.js │ │ └─ recentNews.js │ └─ utils │ ├─ autoRolling.js │ ├─ changeView.js │ ├─ checkPage.js │ ├─ getDate.js │ ├─ makeGridView.js │ ├─ makeListView.js │ └─ reload.js └─ readme.md Feature list # 개발 완료한 기능 # [기본 화면] - [x] 메인 로고 클릭 시 새로고침 - [x] 시스템 날짜 표현 [최신 뉴스 영역] - [x] 최신 뉴스 5초마다 5개 자동 롤링 - [x] 좌우 영역 1초 차이 롤링 - [x] 마우스 호버 시 롤링 일시정지 [그리드 뷰] - [x] 새로고침 시 언론사 로고 랜덤 표시 - [x] 첫 페이지, 마지막 페이지 버튼 disable - [x] 뷰 방식 변경 - [x] 마우스 호버 시 구독하기 버튼 표시 [리스트 뷰] - [x] 클릭한 카테고리의 현재 언론사 순서와 총 언론사 수 표시 - [x] 버튼 클릭 시 해당 카테고리의 다음 언론사로 넘어가기 - [x] 20s간 프로그레스 바 진행 후, 다음 언론사로 넘어가기 남은 기능 # (오늘 구현한 기능은 형광펜 표시)\n구독하기/해지하기 버튼 리스트 뷰 메인 로고 썸네일에 마우스 호버 시 5% 확대 구독한 언론사 탭 버튼 이벤트 구독한 언론사 페이지 구현 \u0026lt;- 구현하다가 개발 시간이 끝났다. 그리드 뷰 마지막 페이지 언론사 로고 갯수 96개 아닐 때 그리드 표시 다크모드 (추가 미션) 개발한 기능 시연 # 원래 카테고리 바에 프로그레스 바 진행이 나타나야 하는데 개발 도중에 끝나서 캡쳐를 못했다.\n어려웠던 점 # 문제 상황 # 이벤트 위임을 적용하고 싶어서 리스트뷰전체에서 이벤트를 받았다. 리스트뷰에서 언론사 구독하기 클릭이벤트를 등록할 때 페이지가 증가할수록 그 수만큼 이벤트가 중첩됐다.\n시행착오 #1 # removeEventListener를 통해 이벤트를 제거하려고도 해봤으나 제거하면 클릭을 한번밖에 못함\n시행착오 #2 # 각 언론사 뉴스 정보를 세분화해서 그려주는 drawPressInfo.js 파일에서 각각의 구독하기 버튼에 제한해서 클릭이벤트를 적용\n해결 코드 # # pressNewsInfo.js 이벤트 리스너 등록한 부분 export function drawPressInfo(category_news, subscribedPress, press) { const press_news = document.querySelector(\u0026#34;.press-news\u0026#34;); press_news.innerHTML = `\u0026lt;div class=\u0026#34;press-info\u0026#34;\u0026gt; \u0026lt;img id=\u0026#34;press-logo\u0026#34; alt=\u0026#34;press-logo\u0026#34; src=\u0026#34;${category_news.src}\u0026#34; /\u0026gt; \u0026lt;span class=\u0026#34;edit-date\u0026#34;\u0026gt;${category_news.edit_date} 편집\u0026lt;/span\u0026gt; \u0026lt;div class=\u0026#34;sub\u0026#34;\u0026gt; \u0026lt;button class=\u0026#34;sub subscribe\u0026#34;\u0026gt; \u0026lt;img src=\u0026#34;../assets/icons/plus.svg\u0026#34; /\u0026gt; \u0026lt;span\u0026gt;구독하기\u0026lt;/span\u0026gt; \u0026lt;/button\u0026gt; \u0026lt;button class=\u0026#34;sub cancel\u0026#34;\u0026gt; \u0026lt;img src=\u0026#34;../assets/icons/closed.svg\u0026#34; /\u0026gt; \u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt;`; showSubscribeButton(subscribedPress, press); const newDiv = document.createElement(\u0026#34;div\u0026#34;); newDiv.classList.add(\u0026#34;news-content\u0026#34;); press_news.appendChild(newDiv); const sub_btn = document.querySelector(\u0026#34;.press-info .sub\u0026#34;); sub_btn.addEventListener(\u0026#34;click\u0026#34;, (e) =\u0026gt; handleClick(e, subscribedPress, press) ); } 언론사 정보를 그려주는 함수에서 버튼에 클릭 이벤트를 등록했다. 버튼이 클릭되면 아래의 함수가 실행된다. 아래의 함수는 버튼이 구독한 상태에서 누른 버튼인지, 아닌 상태에서 누른 버튼인지를 해당 버튼의 클래스로 조건문을 판별한다. cancel이 클래스에 포함되어 있을 경우, 현재 리스트 뷰의 버튼은 해지하기 버튼이므로 구독한 상태를 의미한다. 따라서 해당 버튼이 눌렸을 때에는 해지 처리를 아닌 경우에는 구독 처리를 해주었다.\n# pressNewsInfo.js 클릭 이벤트가 실행시켜주는 함수 function handleClick(e, subscribedPress, press) { const btn_target = e.target.closest(\u0026#34;button\u0026#34;); const press_news = document.querySelector(\u0026#34;.press-news\u0026#34;); const newDiv = document.createElement(\u0026#34;div\u0026#34;); if (btn_target) { console.log(subscribedPress, subscribedPress.includes(press)); if (btn_target.classList.contains(\u0026#34;cancel\u0026#34;)) { console.log(\u0026#34;해지\u0026#34;); newDiv.classList.add(\u0026#34;popup\u0026#34;, \u0026#34;alert\u0026#34;); newDiv.innerHTML = ` \u0026lt;div class=\u0026#34;message\u0026#34;\u0026gt;\u0026lt;span class=\u0026#34;press\u0026#34;\u0026gt;${press}\u0026lt;/span\u0026gt;을(를)\\n구독해지하시겠습니까?\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;buttons\u0026#34;\u0026gt; \u0026lt;button class=\u0026#34;btn-yes\u0026#34;\u0026gt;예, 해지합니다\u0026lt;/button\u0026gt; \u0026lt;button class=\u0026#34;btn-no\u0026#34;\u0026gt;아니오\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt;`; press_news.appendChild(newDiv); const btn = document.querySelector(\u0026#34;.buttons\u0026#34;); btn.addEventListener(\u0026#34;click\u0026#34;, (e) =\u0026gt; checkAnswer(e, subscribedPress, press) ); } else { console.log(\u0026#34;현재 언론사\u0026#34;, press); subscribedPress = [...subscribedPress, press]; newDiv.classList.add(\u0026#34;popup\u0026#34;, \u0026#34;snackbar\u0026#34;); newDiv.textContent = \u0026#34;내가 구독한 언론사에 추가되었습니다.\u0026#34;; press_news.appendChild(newDiv); showSubscribeButton(subscribedPress, press); parentCallback(subscribedPress); newDiv.addEventListener(\u0026#34;animationend\u0026#34;, handleAnimationEnd); }}} 아직 리팩토링 전이라 매우 코드가 보기 힘들다. console.log도 안 지운 코드 (\u0026hellip;)\n향후 계획 # 코드 리뷰하면서 같은 팀원 분 중 한 분이 고수신데 store.js, 옵저버 패턴을 사용했다. 지금 건드렸다간 버그 투성이일 것 같아서 못했지만 기능 구현을 완료하고 리팩토링을 할 때 한 번 사용하고 싶다. 내일은 내가 구독한 언론사 탭을 구현해야 한다. 이 탭은 기본 틀은 카테고리 별 뉴스와 같아서 카테고리를 그려주는 함수의 파라미터를 손보다가 개발 시간이 끝나서 현재 지금 안 돌아가는 상태로 존재한다. ㅎㅎ 내일은 버그를 고쳐야겠다. ","date":"17 July 2023","permalink":"/posts/fe-newsstand/fe-newsstand1/","section":"Posts","summary":"FE 뉴스스탠드 3주차 # 참고 fe-newsstand #3 fe-newsstand 7.","title":"[현대 소프티어] FE 뉴스스탠드 #1"},{"content":"Hugo와 Github page를 이용한 블로그 제작 # 블로그 제작 결심 # 원래도 공부하고 시간이 지나면 까먹고 같은 것을 찾아보는 것을 깨닫고 새롭게 안 것을 기록해야 할 필요성을 느꼈다. 생각만 하고 흐지부지 되던 차에 과 방학 행사 중 하나로 블로그 챌린지를 진행한다고 해서 블로그를 개발하게 되었다. 또한 4학년 여름 방학 2개월동안 현대 소프티어 부트캠프를 수료하는데 여기서 배운 것들을 기록하면 정말 좋을 것 같았다.\nHugo를 선택한 이유 # jekyll\n- ruby 기반 - 한글 레퍼런스가 많다 - 빌드 시 시간이 오래 걸린다. (이게 가장 큰 단점인듯) Hugo - Golang 기반 - 가장 빠르다. - 한글 레퍼런스가 적다. Hexo\n- JavaScript 기반 - 속도는 jekyll보다 빠르고 hugo보다 느리다. - 중국 레퍼런스가 많다. 이렇게 세 가지가 유명한 것 같다. 검색해보니까 jekyll에서 hugo로 넘어간 글이 보이고 hugo가 빌드 시 빠르다는 것, 그리고 테마를 구경하고 마음에 든 것이 있어서 hugo를 선택했다.\nHugo 설치 # 설치는 os에 따라 다르다. 현재 2개월 간 시한부 맥북 신세라 (\u0026hellip;) brew install을 통해 설치해주었다. 윈도우는 본인이 사용하고 싶은 테마가 SCSS를 포함하고 있으면 확장 버전을 따로 설치해야 하는 것 같았다.\n# hugo 설치 $ brew install hugo # hugo 버전 확인 $ hugo version Git 레포지토리 생성 # Git 레포지토리는 총 2개 생성해주면 된다.\n블로그 포스트 저장용 렌더링용 페이지 (github.io) 2번의 경우에는 원하는 레포지토리 이름이 있더라도 {username}/github.io로 하고 배포한 다음, 이름을 수정해야 한다. Hugo 블로그 프로젝트 생성 # 원하는 프로젝트 이름으로 hugo 프로젝트 hugo new site blog를 생성한다. 나의 경우에는 blog로 프로젝트 이름을 지정했다.\nHugo 테마 적용 # 테마마다 다운로드하는 방법이 친절하게 설명되어 있다. 나의 경우에는 congo 테마를 사용했다. 여기서부터는 Go 언어도 설치가 된 상태여야 한다. Go 역시 brew를 통해 설치했다.\nHugo 프로젝트 디렉토리 구성 # 테마마다 디렉토리 구조가 다른데 형식(이름)을 같게 해주어야 한다. 아래는 내가 적용한 테마의 기본 구조이다.\n. ├── assets │ └── img │ └── author.jpg ├── config │ └── _default ├── content │ ├── _index.md │ ├── about.md │ └── posts │ ├── _index.md │ ├── first-post.md │ └── another-post │ ├── aardvark.jpg │ └── index.md └── themes └── congo 이후로는 샘플과 깃허브 코드들을 보면서 config/_default/params.toml등을 원하는 설정으로 변경했다.\nGithub 연동 # Repository 연결 # 1. 포스트 관리용으로 만든 레포지토리와 연결 # git remote add origin \u0026lt;repo 주소\u0026gt;\n2. 호스팅용 레포지토리와 연결 # git submodule add -b main \u0026lt;repo 주소\u0026gt; public\n포스트 업로드 # 이후 포스트를 쓰고 hugo -t \u0026lt;테마이름\u0026gt;을 하면 public에 html 파일이 생성된다. 생성된 public 디렉토리에 들어가서 변경된 부분들을 commit 해주면 본인의 github page 주소에 반영이 된다.\nHugo와 Github page를 이용한 블로그 제작 총평 # 블로그 제작 후기 # 테마가 예쁘고 다크모드 구현, 태그, 검색 등 다양한 기능이 들어있어서 좋았다.\n내가 고른 테마는 다국어 번역 기능을 지원하지만 한국어를 지원해주지 않았다. 나중에 시간적 여유가 생긴다면 한국어로 pr을 날려봐도 좋을 것 같다.\n향후 계획 # 자동 배포를 통한 자동화 도메인을 구매 후 적용 (가능하다면) ","date":"15 July 2023","permalink":"/posts/create-blog/create-blog/","section":"Posts","summary":"Hugo와 Github page를 이용한 블로그 제작 # 블로그 제작 결심 # 원래도 공부하고 시간이 지나면 까먹고 같은 것을 찾아보는 것을 깨닫고 새롭게 안 것을 기록해야 할 필요성을 느꼈다.","title":"Hugo 블로그 제작기"},{"content":"","date":null,"permalink":"/tags/%EB%B8%94%EB%A1%9C%EA%B7%B8-%EC%A0%9C%EC%9E%91%EA%B8%B0/","section":"Tags","summary":"","title":"블로그 제작기"},{"content":"","date":null,"permalink":"/categories/","section":"Categories","summary":"","title":"Categories"}]