[{"content":"","date":null,"permalink":"/","section":"","summary":"","title":""},{"content":"","date":null,"permalink":"/posts/","section":"Posts","summary":"","title":"Posts"},{"content":"","date":null,"permalink":"/tags/","section":"Tags","summary":"","title":"Tags"},{"content":"명탐정 코난: 흑철의 어영에서의 AI 기술 # 오늘 명탐정 코난: 흑철의 어영 영화를 봤는데 이번 영화에서 AI 기술이 많이 나와서 한번 알아보는 시간을 가지겠다. 미션 임파서블도 AI 기술이 나왔다는데 요즘 영화 트렌드인가보다. 스포일러에 최대한 주의하면서 기술에 집중하겠다.\n영화 속에서의 생장 인식 프로그램 # 어릴 때의 사진 데이터를 기반으로 몇 년 후의 모습을 유추해서 전 세계의 통합된 CCTV 데이터를 기반으로 사람을 찾는 기술이다. 아래의 줄거리 말 중 하나처럼 이 기술을 통해 여러 사건 해결에 도움을 줄 수 있다.\n일본과 유럽의 CCTV 정보를 확인할 수 있을 뿐 아니라, 장기 수배범이나 유괴당한 피해자를 전 세계에서 찾아낼 수 있는 ‘전연령 인식’이라는 획기적인 AI 기술을 개발 중이다.\n의문점 # 사실 보면서 여러 의문점이 있었다. 베르무트가 나중에 파훼법으로 (흠.. 스포일러인가) 닮은 사람으로 변장을 해서 기술의 신뢰도를 낮춘 장면이 있다. 여기서 생긴 의문이 그렇다면 오직 외관으로 이후의 모습을 예측하고 찾는다면 외관을 변형시킨다던가 아니면 쌍둥이 등 닮은 사람의 존재의 처리가 궁금해졌다. 뭐 영화는 영화로 봐야겠지만\n딥페이크 기술 # 스포일러 주의 영화 속에서 CCTV가 cg를 통해 딥페이크 기술이 적용된 것이라고 코난이 추리를 하는 장면이 있다.\n딥페이크란? # 작년에 코인이 유행할 때 일론 머스크와 관련해서 유튜브에 딥페이크 기술이 많이 등장했다. 딥페이크 기술은 과연 무엇일까?\n바로 딥러닝 기술을 이용해서 만든 가짜 이미지를 전체적으로 Deepfake 기술이라고 한다.\n동작 과정 # 데이터 수집: 합성하고자 하는 인물의 이미지나 동영상 데이터를 수집한다. 작중에서는 대상자가 내부 직원이라 충분한 양의 데이터가 있었다! 데이터 전처리: 수집한 데이터를 얼굴 영역만 추출하거나 필요한 크기로 변환한다. 인공지능 학습: GAN을 사용하여 생성자와 판별자를 학습시킨다. 생성자는 실제 얼굴과 비슷한 가짜 얼굴을 생성하도록 학습하고, 판별자는 진짜와 가짜를 잘 구분하도록 학습한다. 딥페이크 생성: 학습된 생성자를 사용하여 새로운 인물의 얼굴을 생성한다. 이 때, 다른 사람의 얼굴을 합성하여 딥페이크 영상을 만들 수 있습니다. 나는 생장 인식보다는 딥페이크 기술에 대해 관심이 더 갔는데 GAN 기술은 facebook의 AI 총괄을 맡은 ‘얀 르쿤’이 최근 10년 간 머신러닝 분야에서 가장 멋진 아이디어라고 할 만큼 혁신적인 기술이라고 한다. 확실히 강력한 기술이니만큼 악용될 소지가 많다. 작중에서와 같이 가짜 이미지를 통해 CCTV를 조작하는 등..\n동작 원리 # 이미지나 영상 처리는 사실 숫자로 이루어져 있다. 따라서 이러한 이미지나 영상을 수정하는 것은, 숫자를 변경하는 것과 같다. 그렇다면 숫자는 어떻게 변경하는가? 가장 중요한 것은, 행렬곱이다. 이미지 변경은 행렬의 연속적인 연산을 통해서 이루어진다. Fundamental math 수학적 연산 중에서 합성곱(convolution)는 영상 처리에 쓰이고 중요하다. 자세한 내용은 위키 참고\nCNN과 GAN CNN과 GAN은 딥러닝의 기본 개념이다. CNN은 Convolutional Neural Network로 convolution을 여러 겹 쌓은 딥러닝 구조를 뜻한다. GAN은 Generative Adversarial Network로, generator와 discriminator가 각각 지폐위조범과 경찰처럼 서로 잡고 잡히지 않기 위해 발달하는 원리를 차용한 딥러닝입니다. 따라서 이 기술들을 사용해서 동작 과정에서 말한 3번을 진행하면서 딥페이크를 생성한다.\n마치며 # 영화를 보면서 전공과 관련 기반 지식과 연관지어 생각하면서 재밌으면서도 현실성이 조금 없어서 비판적인 시각으로도 본 것 같다. 아쉬운 면이 다소 몇 가지 존재하지만 일반 영화보다는 전공 관련 지식이 많이 나와서 흥미로운 시선으로 보았다.\n","date":"22 July 2023","permalink":"/posts/study-in-movie/study-in-movie1/","section":"Posts","summary":"명탐정 코난: 흑철의 어영에서의 AI 기술 # 오늘 명탐정 코난: 흑철의 어영 영화를 봤는데 이번 영화에서 AI 기술이 많이 나와서 한번 알아보는 시간을 가지겠다.","title":"명탐정 코난: 흑철의 어영에서의 AI 기술"},{"content":"","date":null,"permalink":"/tags/%EC%98%81%ED%99%94-%EC%86%8D-%EA%B3%B5%EB%B6%80/","section":"Tags","summary":"","title":"영화 속 공부"},{"content":"FE 뉴스스탠드 3주차 # 참고 fe-newsstand #3\nDone # 오늘은 3주차 마지막이지만 기획 리뷰와 세미나 시간으로 대부분 보내서 개발을 많이 하지 못했다. 주말동안 힘내서 기능 구현을 많이 해놔야겠다. 그런 의미로 오늘은 세미나와 코드리뷰에서 알게된 것들을 정리하겠다.\n세미나 #1 바닐라 JS를 이용한 컴포넌트 방식 개발 # 컴포넌트란 # 재사용이 가능한 각각의 독립된 모듈로, 컴포넌트들을 조합하여 화면을 구성할 수 있다. 현 시점에서의 웹 어플리케이션은 컴포넌트 단위로 설계한다.\n컴포넌트 방식 개발 # 한번 만들면 필요시 조금씩 바꿔서 재사용이 가능하다. 컴포넌트 기준으로 전체적인 구조 파악이 용이하다. 코드 중복 및 다른 모듈과의 의존성을 낮춰준다. 코드 수정시 해당 컴포넌트만 수정하기 때문에 유지 보수하기에 좋다. 바닐라 js 특징 # 컴포넌트별 state setState 호출 =\u0026gt; 현재 state가 업데이트되고 render된다. 단, 렌더링 범위를 지정해야한다는 단점이 있다. state, props를 통해 객체 이용을 관리한다. =\u0026gt; 순서 상관없이 원하는 key에 접근 가능하다. 컴포넌트 내부 함수는 화살표 함수로 구현한다. 화살표 함수 vs 일반 함수 # 화살표 함수와 일반 함수는 this 바인딩에 차이가 있다. 화살표 함수: 상위 객체 일반 함수: window 객체 (브라우저), global 객체(node.js) 최초 렌더링 시에만 실행 세미나 #2 웹페이지 이미지 최적화 # 이미지 최적화 기법 # 웹페이지 로딩 시간에는 js 파일과 이미지가 많은 영향을 끼친다. 따라서 티가 안나는 선에서 최대한 용량을 줄이면 속도 향상에 도움이 된다. 아래는 이미지 최적화 기법들이다.\nImage compression # 압축률을 높여 이미지용량 줄이기\nResizing # 사용자화면 사이즈에 맞게 이미지 사이즈 변경\nImage format # 용량이 작은 이미지 포맷으로 변경하기 webp 인터넷에서 이미지 로딩 시간 단축을 위해 google이 만든파일 포맷\nResponsive image 반응형 이미지 # pc는 4k를 쓸 일이 있지만 모바일은 없다. 따라서 이런 경우, media-query를 사용하여 반응형 이미지 사용하기!\nLazy Loading # 최대한 이미지 파일 늦게 불러오기 뷰포트 이내에 있거나 가까울때 이미지 불러오기 =\u0026gt; 처음에 웹페이지 불러올 때 빠르게 띄울 수 있음\nhtml =\u0026gt; img 태그에 loading = \u0026#34;lazy\u0026#34; js =\u0026gt; intersectionObserver Place holder # 레이아웃 시프트 이미지 로딩에 시간이 걸리면서 레이아웃이 이동되는 현상이다. 레이아웃 시프트는 placeholder 처리를 통해 해결할 수 있다.\nImage sprite # 이미지 에셋들을 모아서 한번에 불러오기\n해결 방법 # next.js 사용: next.js는 위의 이미지 최적화 관련된 기능들을 다 제공.\nnuxtImage\ncloudinary (프론트보다는 백엔드에서 처리하는 기법)\n마치며 # 코드 리뷰 회고 # 이벤트 핸들러는 무조건 분리하기 classList.remove, classList.add 안하고 =으로 변경할 수도 있다. 단, 싹 다 바뀌기 때문에 주의. await은 blocking 되기 때문에 관련 없는 것들은 동작되게 위로 옮기기 store\n상태 정의, 상태를 변경시켜주는 메소드가 있어야 한다.\nsubscribe 메소드: store 객체를 구독한다. 메소드가 없으면 상위 객체로 찾는다. =\u0026gt; prototype을 가지고 동작하도록\u0026hellip; ","date":"21 July 2023","permalink":"/posts/fe-newsstand/fe-newsstand5/","section":"Posts","summary":"FE 뉴스스탠드 3주차 # 참고 fe-newsstand #3","title":"[현대 소프티어] FE 뉴스스탠드 #5"},{"content":"","date":null,"permalink":"/tags/newsstand/","section":"Tags","summary":"","title":"newsstand"},{"content":"","date":null,"permalink":"/tags/%ED%94%84%EB%A1%A0%ED%8A%B8%EC%97%94%EB%93%9C/","section":"Tags","summary":"","title":"프론트엔드"},{"content":"","date":null,"permalink":"/tags/%ED%98%84%EB%8C%80%EC%86%8C%ED%94%84%ED%8B%B0%EC%96%B4/","section":"Tags","summary":"","title":"현대소프티어"},{"content":"FE 뉴스스탠드 3주차 # 참고 fe-newsstand #3 fe-newsstand 7.20\nDone # 어제 적은 피드백 일부를 반영했다. 오늘은 오전 시간(10~12시)을 제외하고 2시~5시까지 회사 설명회를 듣느라 개발에 시간을 많이 쏟지 못했다.\n[코드리뷰 피드백] 반영한 것은 취소선 표시\ncore은 개발자들이 볼 때 전체 페이지를 아우르는 느낌이기 때문에 조심해야 함 file 이름 상단에 모듈 역할 적기 getView의 경우에는 뷰를 얻어오는 것이 아니라 view mode를 얻어오는 것이기 때문에 getViewMode와 같이 변경 camel case와 _ 중 네이밍 일관성있게 통일시키기 swtich case에서 target 부분 명확하게 이름짓기 이미지, url들은 다 분리하기 주석, console.log도 커밋할 때 지우기 template literal은 html처럼 들여쓰기 등으로 보기 좋게 =\u0026gt; 만약 너무 길어지면 로직 빼내기 reducer 사용해보기 parentelement 같은 경우는 여러 번 중첩해서 쓰지 않기 =\u0026gt; DOM은 변경에 취약하기 때문에 많이 쓰면 파악 어려워짐 =\u0026gt; 이렇게 보니까 리팩토링을 많이 한다고 했는데 적게 했다. 하면서 고민이 생겼는데 이미지 url, 데이터 경로들을 constants.js로 분리하는 과정에 생긴 고민이다. 자세한 것은 아래(고민점)에 후술하겠다.\n경로 분리 이유 # 데이터나 이미지 같은 경우는 로컬이 아니라 서버에 저장되는데 분리하지 않을 경우 유지 보수가 어렵다. 따라서 개발 시에도 따로 분리해서 적어주는게 이후의 수정 및 개발을 위해서도 좋다고 한다.\nObject.freeze() # Object.freeze() 메서드는 객체를 변경할 수 없게 만든다.(read only) 아래의 경우와 같이 값을 바꾸려고 하면 오류를 던지는 것 같다.\nconst obj = { prop: 42, }; Object.freeze(obj); obj.prop = 33; // Throws an error in strict mode console.log(obj.prop); // Expected output: 42 Object.seal() # Object.freeze()를 공부하다가 Object.seal()이란 것도 존재하는 것을 알았다.\n// 1. 프로퍼티를 변경하는 경우 obj.a = 200; console.log(obj.a); // 200 // 2. 프로퍼티를 제거하는 경우 delete obj.a; console.log(obj.a); // 200 // 3. 새로운 프로퍼티를 추가하는 경우 obj.b = 500; console.log(obj.b); // undefined 무슨 차이인지 알겠는가? 결론적으로는 freeze가 제한이 더 많다. seal은 프로퍼티를 수정할 수 있지만 freeze는 불가능하다. 공통점으로는 전달된 객체들은 확장할 수 없게 되어 새로운 속성을 추가할 수 없다. 전달된 객체 내부의 모든 요소들은 구성 불가능하게 되어 삭제할 수 없다.\nAfter Refactoring # # constants.js (생략) export const ICON_IMG_PATH = \u0026#34;../assets/icons/\u0026#34;; export const DATA_PATH = \u0026#34;../data/\u0026#34;; Object.freeze({ DATE_UPDATE_TIME, RECENT_NEWS_CNT, ROLLING_WAIT_TIME, ROLLING_DIFF_TIME, FIRST_PAGE_NUM, LAST_PAGE_NUM, PRESS_CNT, SNACKBAR_WAIT_TIME, PRESS_LOGO_IMG_PATH, ICON_IMG_PATH, }); 마치며 # 고민점 # html의 이미지 태그의 경로는 어떻게 바꿀지 아직 고민중이다. app.js로 진입점을 하나로 설정해서 모듈들을 import하려고 했는데 html에서 constants들을 쓰자니 script로 불러와야 한다\u0026hellip; 어떡해야 할지 몰라서 아직 변경은 못했다.\n앞으로 할 일 # 집에 가서 이번주 한 일의 데모 영상을 촬영해야 한다. 길이는 1~5분 내외로 삽질한 것 내용을 위주로 설명해야 한다. 나는 아마 처음에 구독한 언론사를 콜백으로 변수를 관리하다가 이후 파라미터 관리가 복잡해져서 store와 옵저버 패턴으로 리팩토링한 과정을 설명할 것 같다.\n","date":"20 July 2023","permalink":"/posts/fe-newsstand/fe-newsstand4/","section":"Posts","summary":"FE 뉴스스탠드 3주차 # 참고 fe-newsstand #3 fe-newsstand 7.","title":"[현대 소프티어] FE 뉴스스탠드 #4"},{"content":"FE 뉴스스탠드 3주차 # 참고 fe-newsstand #3 fe-newsstand 7.19 fe-newsstand 7.19 Done # 오늘은 기능 구현보다는 주로 리팩토링에 힘을 썼다. 오전 시간(10~12시)에는 store와 view를 느슨하게 하기 위해 고민을 했다. 똑똑한 gpt와 블로그를 참고하여 store class를 만들고 observer 함수에 등록했다. 자세히 설명하겠다. (이해가 아직 다 된 것은 아니라 완벽하게 내 코드가 되진 않았다.)\nRefactoring # 옵저버 패턴으로 리팩토링을 진행하였다. 원래는 콜백 함수를 사용해서 값이 바뀌면 부모에게 전달해주었는데 코드가 많이 복잡했다. 옵저버는 1대 다 구조에 유리하고 상태가 변경되면 알아서 바꿔준다! (리덕스, PubSub 패턴과 유사) 중앙 집중식이라고 생각해서 store.js, observer.js와 getter.js는 core 폴더에 넣어주었다.\nStore # # store.js import { FIRST_PAGE_NUM } from \u0026#34;../constants/constants.js\u0026#34;; import { observable } from \u0026#34;./observer.js\u0026#34;; class Store { constructor() { this.state = observable({ mode: \u0026#34;light\u0026#34;, //추후 다크모드 view: \u0026#34;grid\u0026#34;, //그리드뷰 또는 리스트뷰 page: FIRST_PAGE_NUM, //현재 페이지 tabMode: \u0026#34;all\u0026#34;, //all 전체언론사 sub 구독한 언론사 subscribedPress: [\u0026#34;서울경제\u0026#34;, \u0026#34;데일리안\u0026#34;, \u0026#34;헤럴드경제\u0026#34;], }); } setState(newState) { for (const [key, value] of Object.entries(newState)) { if (!this.state.hasOwnProperty(key)) continue; this.state[key] = value; } } } export const store = new Store(); Observer # # observer.js let currentObserver = null; export const observe = (fn) =\u0026gt; { currentObserver = fn; fn(); currentObserver = null; }; export const observable = (obj) =\u0026gt; { Object.keys(obj).forEach((key) =\u0026gt; { let _value = obj[key]; const observers = new Set(); Object.defineProperty(obj, key, { get() { if (currentObserver) observers.add(currentObserver); return _value; }, set(value) { _value = value; observers.forEach((fn) =\u0026gt; fn()); }, }); }); return obj; }; observable은 객체의 속성에 get, set을 정의하여 관찰 가능한 상태로 만드는 함수이다. 즉, observable 함수를 사용하면 객체의 속성 값을 조회하고 할당할 때 특별한 동작을 추가하여 상태 변경을 감지할 수 있게 된다.\nobservable 함수를 사용하여 만든 객체의 속성은 Getter와 Setter가 적용되어, 속성의 값이 변경되거나 조회될 때 등록된 옵저버들이 자동으로 호출된다. 이를 통해 상태 변경을 감지하고, 등록된 옵저버들이 자동으로 업데이트되는 상태 관리를 할 수 있다.\n따라서 observable 함수를 사용하여 만든 store 객체는 관찰 가능한 상태를 가지며, 속성의 값이 변경되면 등록된 옵저버들이 자동으로 호출되어 상태 변경을 감지할 수 있다. 이를 통해 상태 조회 로직과 상태 변경 로직을 분리하여 코드를 더 모듈화하고, 상태 변화에 따른 반응을 자동화할 수 있다. (gpt의 설명 참고 ㅎㅁㅎ)\nGetter # # getter.js import { store } from \u0026#34;./store.js\u0026#34;; import { observe } from \u0026#34;./observer.js\u0026#34;; export function getMode() { return store.state.mode; } export function getView() { return store.state.view; } export function getPage() { return store.state.page; } export function getTabMode() { return store.state.tabMode; } export function getSubscribedPress() { return store.state.subscribedPress; } // 옵저버 등록 observe(getMode); observe(getView); observe(getPage); observe(getTabMode); getter는 store에 넣어도 된다. 하지만 store에는 순수한 데이터를 저장하고 어댑터 역할로 뷰에 전달하도록 필터 느낌으로 사용하고 싶다면 getter함수들을 따로 빼도 된다. 이 경우, test와 유지보수에 용이하다는 장점이 있다고 한다. store은 view에 dependency가 없고 메소드 정도는 있어도 된다. 하지만 순수할수록 좋다고 한다. 또한 옵저버 등록하는 부분들이 숨겨져 있는 것 같다고 크롱님께서 피드백을 주셨다. 명확하게 기능을 보이기 위해 어디에 위치시킬지 고민해봐야겠다.\n마치며 # 오늘 코드 피드백 시간에 3개 중 하나가 내 코드가 걸렸다. 덕분에 내 코드를 다시 돌아보고 이해하는 과정을 겪었다. 피드백을 반영할 것들을 메모해봤다.\n[스쿼드세션]\n상수에 freeze를 사용하면 read only가 되어서 값을 수정할 수 없다. 변하는 state는 대문자 사용하지 않기 [코드리뷰 피드백]\ncore은 개발자들이 볼 때 전체 페이지를 아우르는 느낌이기 때문에 조심해야 함 file 이름 상단에 모듈 역할 적기 getView의 경우에는 뷰를 얻어오는 것이 아니라 view mode를 얻어오는 것이기 때문에 getViewMode와 같이 변경 camel case와 _ 중 네이밍 일관성있게 통일시키기 swtich case에서 target 부분 명확하게 이름짓기 이미지, url들은 다 분리하기 주석, console.log도 커밋할 때 지우기 template literal은 html처럼 들여쓰기 등으로 보기 좋게 =\u0026gt; 만약 너무 길어지면 로직 빼내기 reducer 사용해보기 parentelement 같은 경우는 여러 번 중첩해서 쓰지 않기 =\u0026gt; DOM은 변경에 취약하기 때문에 많이 쓰면 파악 어려워짐 ","date":"19 July 2023","permalink":"/posts/fe-newsstand/fe-newsstand3/","section":"Posts","summary":"FE 뉴스스탠드 3주차 # 참고 fe-newsstand #3 fe-newsstand 7.","title":"[현대 소프티어] FE 뉴스스탠드 #3"},{"content":"FE 뉴스스탠드 3주차 # 참고 fe-newsstand #3 fe-newsstand 7.18 Feature List # 남은 기능 # (오늘 구현한 기능은 형광펜 표시)\n구독하기/해지하기 버튼\n리스트 뷰 메인 로고 썸네일에 마우스 호버 시 5% 확대\n구독한 언론사 탭 버튼 이벤트\n구독한 언론사 페이지 구현 + 구독/해지 이벤트\n그리드 뷰 마지막 페이지 언론사 로고 갯수 96개 아닐 때 그리드 표시\n다크모드 (추가 미션)\n개발한 기능 시연 # 구독/해지 이벤트를 구현하는 것까지 완료하였으나 지금 코드가 스파게티 코드 상태라 리팩토링을 빡세게 진행해야 한다.\n학습한 내용 # 주차 중 화요일, 수요일은 자바스크립트 관련 수업을 듣는다. 이번 수업에서는 scope, closure, 비동기, promise, json 객체 등 얼핏 알고 있었지만 자세히는 몰랐던 개념에 대해 알았다. 수업시간에 코드 예시를 실행하면서 원리를 알았지만 아직 내 지식으로 습득은 안 된 것 같아서 집에 돌아가면 다시 천천히 봐야겠다.\nScope # Scope chaining # 함수가 해당하는 값을 block -\u0026gt; closure 이런 식으로 올라가면서 scope를 올라가면서 찾는다.\nvar 함수 레벨 scope\nlet block 레벨 scope\n비동기와 동기 # const baseData = [1, 2, 3, 4, 5, 6, 100]; const asyncRun = (arr, fn) =\u0026gt; { for (var i = 0; i \u0026lt; arr.length; i++) { setTimeout(() =\u0026gt; fn(i), 1000); } }; asyncRun(baseData, (idx) =\u0026gt; console.log(idx)); 수업시간에 다룬 예제 코드 중 하나이다. 결과는 무엇일까?\n정답7이 7번 출력된다. 여기서 var를 let으로 변경하면? var는 함수 level scope, let은 block level scope이다. 따라서 var일 경우 참조값이 closure에 보관되어 있고 이 값은 for문을 7번 다 돈 후의 i이다. 즉 asyncRun의 지역변수 i (값은 7)를 참조한다. let의 경우에는 block level이기 때문에 각 for문 하나가 call stack에 쌓인다. Promise # let myFirstPromise = new Promise((resolve, reject) =\u0026gt; { setTimeout(() =\u0026gt; { resolve(\u0026#34;Success!\u0026#34;); }, 1000); }); myFirstPromise.then((successMessage) =\u0026gt; { console.log(\u0026#34;Yay! \u0026#34; + successMessage); }); 1. Promise객체 2. setTimeout 함수 3. setTimeout에 전달되는 콜백 4. then 함수 5. then에 전달되는 콜백 6. resolve 함수 7. Promise 함수에 전달되는 콜백 중에 실행 순서는 어떻게 될까?\n정답1 7 2 4 3 6 5 실행순서\npromsie 실행 \u0026gt; then 실행(콜백함수 promise에 등록) \u0026gt; 비동기 완료시 resolve 메서드 실행 \u0026gt; 콜백함수 실행\nthen은 동기함수이다. resolve의 신호가 있어야 콜백을 실행한다. fulfilled = 비동기 처리 끝났으니 실행하면 된다는 뜻!\npromise.then은 한 세트로 큐에 같이 들어간다. 또한 다른 큐에 쌓인 함수보다 우선순위가 높다.\n[번외] 화살표 함수 # 이번 수업시간은 아니고 크롱님(수업 담당하시는 분의 닉네임)께서 저번 주차에 숙제로 알아오라고 하셨다. (2번이나\u0026hellip;!)\n// 예시 함수 const exampleFunction = (parameter) =\u0026gt; { // 실행할 내용 }; // 이벤트 리스너 document.addEventListener(\u0026#34;click\u0026#34;, exampleFunction(parameter)); 위의 경우, 가독성 좋게 아래와 같이 변경할 수 있다.\n// 예시 함수 const exampleFunction = (parameter) =\u0026gt; () =\u0026gt; { // 실행할 내용 }; // 이벤트 리스너 document.addEventListener(\u0026#34;click\u0026#34;, exampleFunction(parameter)); 향후 계획 # 유용한 사이트를 많이 알았다. 오늘 학습한 call stack, event loop, queue와 앞으로 적용할 디자인 패턴 같은 내용이 사이트에 포함되어 있다.\n유용한 사이트 # JavaScript 개념 사이트 디자인 패턴 모음 추후 할 것 # 구독한 언론사 탭에서 해지하면 바로 없어지도록 구현하기 리팩토링\n\u0026ndash; store.js, 옵저버 패턴\n\u0026ndash; promise 객체 활용 ","date":"18 July 2023","permalink":"/posts/fe-newsstand/fe-newsstand2/","section":"Posts","summary":"FE 뉴스스탠드 3주차 # 참고 fe-newsstand #3 fe-newsstand 7.","title":"[현대 소프티어] FE 뉴스스탠드 #2"},{"content":"FE 뉴스스탠드 3주차 # 참고 fe-newsstand #3 fe-newsstand 7.17 3주차부터 블로그 시작하는 것이라 제목은 #1이다.\n프로젝트 설명 # 네이버 뉴스스탠드와 비슷한 기능을 하는 뉴스스탠드를 만드는 프로젝트다. 총 4주 기간동안 진행한다. 지금까지 2주가 지났고 오늘 3주차를 시작한다. 현재까지 구현한 기능은 다음과 같다.\n프로젝트 폴더 구조 트리 # fe-newsstand ├─ .DS_Store ├─ assets │ ├─ icons │ └─ images │ └─ logo │ ├─ dark │ └─ light ├─ css │ ├─ color.css │ ├─ index.css │ └─ reset.css ├─ data │ ├─ news.json │ ├─ press.json │ └─ recentNews.json ├─ index.html ├─ js │ ├─ app.js │ ├─ constants │ │ └─ constants.js │ ├─ sections │ │ ├─ header.js │ │ ├─ mainView.js │ │ └─ recentNews.js │ └─ utils │ ├─ autoRolling.js │ ├─ changeView.js │ ├─ checkPage.js │ ├─ getDate.js │ ├─ makeGridView.js │ ├─ makeListView.js │ └─ reload.js └─ readme.md Feature list # 개발 완료한 기능 # [기본 화면] - [x] 메인 로고 클릭 시 새로고침 - [x] 시스템 날짜 표현 [최신 뉴스 영역] - [x] 최신 뉴스 5초마다 5개 자동 롤링 - [x] 좌우 영역 1초 차이 롤링 - [x] 마우스 호버 시 롤링 일시정지 [그리드 뷰] - [x] 새로고침 시 언론사 로고 랜덤 표시 - [x] 첫 페이지, 마지막 페이지 버튼 disable - [x] 뷰 방식 변경 - [x] 마우스 호버 시 구독하기 버튼 표시 [리스트 뷰] - [x] 클릭한 카테고리의 현재 언론사 순서와 총 언론사 수 표시 - [x] 버튼 클릭 시 해당 카테고리의 다음 언론사로 넘어가기 - [x] 20s간 프로그레스 바 진행 후, 다음 언론사로 넘어가기 남은 기능 # (오늘 구현한 기능은 형광펜 표시)\n구독하기/해지하기 버튼 리스트 뷰 메인 로고 썸네일에 마우스 호버 시 5% 확대 구독한 언론사 탭 버튼 이벤트 구독한 언론사 페이지 구현 \u0026lt;- 구현하다가 개발 시간이 끝났다. 그리드 뷰 마지막 페이지 언론사 로고 갯수 96개 아닐 때 그리드 표시 다크모드 (추가 미션) 개발한 기능 시연 # 원래 카테고리 바에 프로그레스 바 진행이 나타나야 하는데 개발 도중에 끝나서 캡쳐를 못했다.\n어려웠던 점 # 문제 상황 # 이벤트 위임을 적용하고 싶어서 리스트뷰전체에서 이벤트를 받았다. 리스트뷰에서 언론사 구독하기 클릭이벤트를 등록할 때 페이지가 증가할수록 그 수만큼 이벤트가 중첩됐다.\n시행착오 #1 # removeEventListener를 통해 이벤트를 제거하려고도 해봤으나 제거하면 클릭을 한번밖에 못함\n시행착오 #2 # 각 언론사 뉴스 정보를 세분화해서 그려주는 drawPressInfo.js 파일에서 각각의 구독하기 버튼에 제한해서 클릭이벤트를 적용\n해결 코드 # # pressNewsInfo.js 이벤트 리스너 등록한 부분 export function drawPressInfo(category_news, subscribedPress, press) { const press_news = document.querySelector(\u0026#34;.press-news\u0026#34;); press_news.innerHTML = `\u0026lt;div class=\u0026#34;press-info\u0026#34;\u0026gt; \u0026lt;img id=\u0026#34;press-logo\u0026#34; alt=\u0026#34;press-logo\u0026#34; src=\u0026#34;${category_news.src}\u0026#34; /\u0026gt; \u0026lt;span class=\u0026#34;edit-date\u0026#34;\u0026gt;${category_news.edit_date} 편집\u0026lt;/span\u0026gt; \u0026lt;div class=\u0026#34;sub\u0026#34;\u0026gt; \u0026lt;button class=\u0026#34;sub subscribe\u0026#34;\u0026gt; \u0026lt;img src=\u0026#34;../assets/icons/plus.svg\u0026#34; /\u0026gt; \u0026lt;span\u0026gt;구독하기\u0026lt;/span\u0026gt; \u0026lt;/button\u0026gt; \u0026lt;button class=\u0026#34;sub cancel\u0026#34;\u0026gt; \u0026lt;img src=\u0026#34;../assets/icons/closed.svg\u0026#34; /\u0026gt; \u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt;`; showSubscribeButton(subscribedPress, press); const newDiv = document.createElement(\u0026#34;div\u0026#34;); newDiv.classList.add(\u0026#34;news-content\u0026#34;); press_news.appendChild(newDiv); const sub_btn = document.querySelector(\u0026#34;.press-info .sub\u0026#34;); sub_btn.addEventListener(\u0026#34;click\u0026#34;, (e) =\u0026gt; handleClick(e, subscribedPress, press) ); } 언론사 정보를 그려주는 함수에서 버튼에 클릭 이벤트를 등록했다. 버튼이 클릭되면 아래의 함수가 실행된다. 아래의 함수는 버튼이 구독한 상태에서 누른 버튼인지, 아닌 상태에서 누른 버튼인지를 해당 버튼의 클래스로 조건문을 판별한다. cancel이 클래스에 포함되어 있을 경우, 현재 리스트 뷰의 버튼은 해지하기 버튼이므로 구독한 상태를 의미한다. 따라서 해당 버튼이 눌렸을 때에는 해지 처리를 아닌 경우에는 구독 처리를 해주었다.\n# pressNewsInfo.js 클릭 이벤트가 실행시켜주는 함수 function handleClick(e, subscribedPress, press) { const btn_target = e.target.closest(\u0026#34;button\u0026#34;); const press_news = document.querySelector(\u0026#34;.press-news\u0026#34;); const newDiv = document.createElement(\u0026#34;div\u0026#34;); if (btn_target) { console.log(subscribedPress, subscribedPress.includes(press)); if (btn_target.classList.contains(\u0026#34;cancel\u0026#34;)) { console.log(\u0026#34;해지\u0026#34;); newDiv.classList.add(\u0026#34;popup\u0026#34;, \u0026#34;alert\u0026#34;); newDiv.innerHTML = ` \u0026lt;div class=\u0026#34;message\u0026#34;\u0026gt;\u0026lt;span class=\u0026#34;press\u0026#34;\u0026gt;${press}\u0026lt;/span\u0026gt;을(를)\\n구독해지하시겠습니까?\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;buttons\u0026#34;\u0026gt; \u0026lt;button class=\u0026#34;btn-yes\u0026#34;\u0026gt;예, 해지합니다\u0026lt;/button\u0026gt; \u0026lt;button class=\u0026#34;btn-no\u0026#34;\u0026gt;아니오\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt;`; press_news.appendChild(newDiv); const btn = document.querySelector(\u0026#34;.buttons\u0026#34;); btn.addEventListener(\u0026#34;click\u0026#34;, (e) =\u0026gt; checkAnswer(e, subscribedPress, press) ); } else { console.log(\u0026#34;현재 언론사\u0026#34;, press); subscribedPress = [...subscribedPress, press]; newDiv.classList.add(\u0026#34;popup\u0026#34;, \u0026#34;snackbar\u0026#34;); newDiv.textContent = \u0026#34;내가 구독한 언론사에 추가되었습니다.\u0026#34;; press_news.appendChild(newDiv); showSubscribeButton(subscribedPress, press); parentCallback(subscribedPress); newDiv.addEventListener(\u0026#34;animationend\u0026#34;, handleAnimationEnd); }}} 아직 리팩토링 전이라 매우 코드가 보기 힘들다. console.log도 안 지운 코드 (\u0026hellip;)\n향후 계획 # 코드 리뷰하면서 같은 팀원 분 중 한 분이 고수신데 store.js, 옵저버 패턴을 사용했다. 지금 건드렸다간 버그 투성이일 것 같아서 못했지만 기능 구현을 완료하고 리팩토링을 할 때 한 번 사용하고 싶다. 내일은 내가 구독한 언론사 탭을 구현해야 한다. 이 탭은 기본 틀은 카테고리 별 뉴스와 같아서 카테고리를 그려주는 함수의 파라미터를 손보다가 개발 시간이 끝나서 현재 지금 안 돌아가는 상태로 존재한다. ㅎㅎ 내일은 버그를 고쳐야겠다. ","date":"17 July 2023","permalink":"/posts/fe-newsstand/fe-newsstand1/","section":"Posts","summary":"FE 뉴스스탠드 3주차 # 참고 fe-newsstand #3 fe-newsstand 7.","title":"[현대 소프티어] FE 뉴스스탠드 #1"},{"content":"Hugo와 Github page를 이용한 블로그 제작 # 블로그 제작 결심 # 원래도 공부하고 시간이 지나면 까먹고 같은 것을 찾아보는 것을 깨닫고 새롭게 안 것을 기록해야 할 필요성을 느꼈다. 생각만 하고 흐지부지 되던 차에 과 방학 행사 중 하나로 블로그 챌린지를 진행한다고 해서 블로그를 개발하게 되었다. 또한 4학년 여름 방학 2개월동안 현대 소프티어 부트캠프를 수료하는데 여기서 배운 것들을 기록하면 정말 좋을 것 같았다.\nHugo를 선택한 이유 # jekyll\n- ruby 기반 - 한글 레퍼런스가 많다 - 빌드 시 시간이 오래 걸린다. (이게 가장 큰 단점인듯) Hugo - Golang 기반 - 가장 빠르다. - 한글 레퍼런스가 적다. Hexo\n- JavaScript 기반 - 속도는 jekyll보다 빠르고 hugo보다 느리다. - 중국 레퍼런스가 많다. 이렇게 세 가지가 유명한 것 같다. 검색해보니까 jekyll에서 hugo로 넘어간 글이 보이고 hugo가 빌드 시 빠르다는 것, 그리고 테마를 구경하고 마음에 든 것이 있어서 hugo를 선택했다.\nHugo 설치 # 설치는 os에 따라 다르다. 현재 2개월 간 시한부 맥북 신세라 (\u0026hellip;) brew install을 통해 설치해주었다. 윈도우는 본인이 사용하고 싶은 테마가 SCSS를 포함하고 있으면 확장 버전을 따로 설치해야 하는 것 같았다.\n# hugo 설치 $ brew install hugo # hugo 버전 확인 $ hugo version Git 레포지토리 생성 # Git 레포지토리는 총 2개 생성해주면 된다.\n블로그 포스트 저장용 렌더링용 페이지 (github.io) 2번의 경우에는 원하는 레포지토리 이름이 있더라도 {username}/github.io로 하고 배포한 다음, 이름을 수정해야 한다. Hugo 블로그 프로젝트 생성 # 원하는 프로젝트 이름으로 hugo 프로젝트 hugo new site blog를 생성한다. 나의 경우에는 blog로 프로젝트 이름을 지정했다.\nHugo 테마 적용 # 테마마다 다운로드하는 방법이 친절하게 설명되어 있다. 나의 경우에는 congo 테마를 사용했다. 여기서부터는 Go 언어도 설치가 된 상태여야 한다. Go 역시 brew를 통해 설치했다.\nHugo 프로젝트 디렉토리 구성 # 테마마다 디렉토리 구조가 다른데 형식(이름)을 같게 해주어야 한다. 아래는 내가 적용한 테마의 기본 구조이다.\n. ├── assets │ └── img │ └── author.jpg ├── config │ └── _default ├── content │ ├── _index.md │ ├── about.md │ └── posts │ ├── _index.md │ ├── first-post.md │ └── another-post │ ├── aardvark.jpg │ └── index.md └── themes └── congo 이후로는 샘플과 깃허브 코드들을 보면서 config/_default/params.toml등을 원하는 설정으로 변경했다.\nGithub 연동 # Repository 연결 # 1. 포스트 관리용으로 만든 레포지토리와 연결 # git remote add origin \u0026lt;repo 주소\u0026gt;\n2. 호스팅용 레포지토리와 연결 # git submodule add -b main \u0026lt;repo 주소\u0026gt; public\n포스트 업로드 # 이후 포스트를 쓰고 hugo -t \u0026lt;테마이름\u0026gt;을 하면 public에 html 파일이 생성된다. 생성된 public 디렉토리에 들어가서 변경된 부분들을 commit 해주면 본인의 github page 주소에 반영이 된다.\nHugo와 Github page를 이용한 블로그 제작 총평 # 블로그 제작 후기 # 테마가 예쁘고 다크모드 구현, 태그, 검색 등 다양한 기능이 들어있어서 좋았다.\n내가 고른 테마는 다국어 번역 기능을 지원하지만 한국어를 지원해주지 않았다. 나중에 시간적 여유가 생긴다면 한국어로 pr을 날려봐도 좋을 것 같다.\n향후 계획 # 자동 배포를 통한 자동화 도메인을 구매 후 적용 (가능하다면) ","date":"15 July 2023","permalink":"/posts/create-blog/create-blog/","section":"Posts","summary":"Hugo와 Github page를 이용한 블로그 제작 # 블로그 제작 결심 # 원래도 공부하고 시간이 지나면 까먹고 같은 것을 찾아보는 것을 깨닫고 새롭게 안 것을 기록해야 할 필요성을 느꼈다.","title":"Hugo 블로그 제작기"},{"content":"","date":null,"permalink":"/tags/%EB%B8%94%EB%A1%9C%EA%B7%B8-%EC%A0%9C%EC%9E%91%EA%B8%B0/","section":"Tags","summary":"","title":"블로그 제작기"},{"content":"","date":null,"permalink":"/categories/","section":"Categories","summary":"","title":"Categories"}]